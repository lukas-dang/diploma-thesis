\chapter{Implementace}
\setcounter{page}{1}

Tato kapitola se zabývá implementací mobilní aplikace a backendu. Kapitola je rozdělena na dvě podkapitoly: jednu pro popis implementace mobilní aplikace a druhou pro popis implementace backendu.

\section{Mobilní aplikace}

V rámci této podkapitoly bude popsána implementace mobilní aplikace. Kapitola je rozdělena do několika sekcí. Na začátku budou popsány nástroje a technologie použité pro implementaci. Následné bude popsána adresářová struktura projektu. Poté bude popsána implementace uživatelského rozhraní. Na konci bude popsána implementace síťové vrstvy pro komunikaci s backendem.

\subsection{Použité nástroje a technologie}
V této sekci budou popsány použité nástroje a technologie, včetně použitých knihoven pro implementaci mobilní aplikace.

\subsubsection *{Android Studio}
Mobilní aplikace byla vytvořena ve vývojovém prostředí Android Studio, což je oficiální IDE pro vývoj mobilních aplikací pro Android. Některé jeho vlastnosti:

\begin{itemize}
	\item \textbf{Podpora pro Android} - Pro vývoj mobilních aplikací pro Android je Android Studio velmi uživatelsky přívětivé. Po spuštění IDE se hned zobrazí průvodce pro instalaci Android SDK obsahující nástroje potřebné pro vývoj aplikací. Po instalaci lze SDK rovnou použít. Není tedy třeba Android SDK manuálně instalovat z internetu a nakonfigurovat s IDE. IDE Dále poskytuje průvodce pro vytvoření projektu, pomocí kterého lze vybrat jednu z existujích šablon pro různé typy projektů. Konfiguraci projektu si uživatel tedy nakliká a IDE se postará o zbytek, tedy vytvoří projektový adresář se všemi potřebnými konfiguračními soubory a počáteční kostru aplikace. Po vytvoření projektu je již k dispozici zatím prázdná, ale spustitelná aplikace.
	
	\item \textbf{Emulátor} - Android Studio poskytuje vestavěný emulátor, který emuluje fyzicka mobilní zařízení. Díky tomu může uživatel testovat své aplikace na různých zařízeních s různými konfiguracemi (např. rozměry zařízení, verze Androidu).
		
	\item \textbf{Klávesové zkratky} - Jeden z hlavních důvodů pro používání IDE založených od JetBrains jsou klávesové zkratky, které jsou stejné pro všechna IDE od JetBrains. Tyto zkratky zrychlují navigaci v kódu a zvyšují produktivitu vývojáře.
\end{itemize}

\noindent zdroj: https://developer.android.com/studio

\subsubsection *{Gradle}
Gradle je nástroj pro automatizaci sestavování programu, tj. automatizace kompilace zdrojového kódu a zabalení výsledného binárního kódu spolu s dalšími zdroji, které zdrojový kód využívá. Toto jsou další výhody Gradlu: 

\begin{itemize}
	\item \textbf{Gradle Pluginy} - Poskytují Gradlu další nástroje jako např. možnost kompilovat Kotlinu, parsovat anotace nebo generovat kód na základě konfiguračního souboru. 
	
	\item \textbf{Externí knihovny} - Pomocí Gradlu lze specifikovat externí knihovny, které se mají automaticky nainstalovat a naimportovat do aplikace pro použití.
	
	\item \textbf{Konfigurace} - Gradle umožňuje konfigurovat pluginy a Android. konfigurace pluginu závisí na daném pluginu. U Androidu lze konfigurovat např. SDK verzi, verzi Kotlinu, aktivaci Jetpack Compose toolkitu. Konfigurací se detailněji zabývá podkapitola o konfiguraci Androidu.
\end{itemize}

zdroj: https://gradle.org/

\noindent Alternativou nástroje Gradle je Maven, který lze také použít pro vývoj mobilní aplikace pro Android. Oba mají své výhody a nevýhody pro různé situace. Rozhodl jsem se však pro Gradle, jelikož při vytváření projektu v Android Studiu nebyla možnost výběru mezi Gradlem a Mavenem. Projekt byl automaticky nakonfigurován pomocí Gradlu. Předpokládám tedy, že Google preferuje Gradle jako nástroj pro tento účel. Maven by se musel nakonfigurovat manuálně, což by pro zprovoznění aplikace bylo časově náročné, a nejspíš i zbytečné. Pokud by však byla jednoduchá možnost, jak zvolit Maven jako nástroj, přesto bych zvolil Gradle, jelikož konfigurace v Gradlu je psána v programovacím jazyce Groovy, který je pro mě mnohem čitelnější než XML, v kterém je psána konfigurace pro Maven.

\subsubsection *{Kotlin}
Pro mobilní aplikaci byl použit programovací jayzk Kotlin, který je od roku 2017 preferovaným jazykem pro Android. Původním programovacím jayzkem pro Android byla Java.	 Kotlin má však oproti němu několik výhod. Toto jsou výhody Kotlinu:

\begin{itemize}
    \item \textbf{Je stručný} - Kotlin umožňuje vytvořit 
    singleton pomocí klíčového slova \lstinline{object}.
    
    \item \textbf{Je bezpečný} - Kotlin rozlišuje null a non-null datové typy. Non-null typy lze dereferencovat vždy, null typy pouze po kontrole výskytu hodnoty null. To je vynuceno typovým systémem Kotlinu. Díky tomu není možné zkompilovat kód, v kterém by se dereferencovala hodnota null, kvůli čemuž by aplikace spadla.
    
    \item \textbf{Je expresivní} - Kotlin byl navržen s důrazem na výstižnost kódu, což přispívá k čitelnosti kódu
\end{itemize}

\noindent Dalším důvodem pro použití Kotlinu souvisí s dlouze běžícími blokujícími operacemi jako např. síťovými a databázovými operacemi. Aplikace běží defaultně na hlavním vláknu, které má na starosti vykreslování obrazovky a obsluhu událostí (např. kliknutí na tlačítko a scrollování). Pokud na něm provedeme dlouze běžící blokující operaci, vlákno se zablokuje na delší dobu a nebude moct obsluhovat události. Uživatelovi se pak aplikace jeví jako zamrznutá. Možným řešením pro tento problém je vytvoření nového vlákna, které bude běžet paralelně s hlavním vlákenm a které bude provádět danou blokující operaci. Operace bude blokovat nově vytvořené vlákno, nebude však blokovat hlavní vlákno, díky čemuž bude uživatel stále moct interagovat s aplikací, i když blokující operace stále běží. Tvorba vláken a jejich správa jsou však drahé operace. 

\vspace{10px}

\noindent\textbf{Kotlin Coroutines} - Alternativním řešením jsou proto Kotlin Coroutines, které umožňují provádět operace paralelně bez nutnosti vytvoření nového vlákna. Coroutina je kus kódu, který je suspendovatelný. To znamená, že ho lze pomocí určitých metod pozastavit (také suspendovat), dokud nebude operace hotová, a tím uvolnit aktuální vlákno pro použití jinde. To se hodí např. pro síťové operace, která stahuje data z internetu. Fungovalo by to tak, že danou síťovou operaci obalíme do coroutiny a až pak operaci provedeme. Ve chvíli kdy operace začne stahovat data z internetu, coroutinu suspendujeme, čímž uvolníme aktuální vlákno pro použití jinde. Jakmile jsou data stažena, kód v suspendované coroutině automaticky pokračuje. To vše probíhá na jednom vlákně. Ukážeme si příklad použití coroutiny je na (\ref{lst:coroutine}).

\begin{lstlisting}[caption={Příklad použití coroutiny}, label={lst:coroutine}, tabsize=2]
fun main() = runBlocking {
	launch {
		delay(1000L)
		println("World!")
	}
	println("Hello")
}
\end{lstlisting}

\noindent Metoda \lstinline|runBlocking| vytvoří tzv. scope, v rámci kterého je vytvořena coroutina pomocí metody \lstinline|launch|. Scope vymezuje životnost coroutinů, které v něm běží. To je užitečné pro zabránění úniku dat. Např. když uživatel spustí aplikaci a pomocí coroutinu se začnou stahovat data z internetu, a aplikaci hned zavře, díky scopu coroutina přestane stahovat data a je zrušena. V rámci metody \lstinline|launch| specifikujeme funkci, která je suspendovatelná, tj. lze ji pozastavit, a tím uvolnit aktuálkní vlákno. Coroutina v tuto chvíli běží sekvenčně se zbytkem kódu, dokud není suspendována. V tomto případě je suspendována pomocí funkce \lstinline|delay|, která ji suspenduje na 1 sekundu. V tuto chvíli je aktuální vlákno uvolněno a je proveden kód následující bezprostředně za coroutinou a vypíše se Hello. V tuto chvíli program ještě neskončí, scope totiž vždy čeká na to, až všechny její coroutiny doběžely. Po 1 sekundě suspendovaná coroutina opět pokračuje a vypíše řetězec World.

Kód (\ref{lst:coroutine-practical}) ilustruje praktičtější příklad, kdy voláme funkci \lstinline|fetchDataFromApi()|, která stahuje data z API a interně operaci suspenduje, díky čemuž se uvolní vlákno a funkce \lstinline|handleUserInteraction()| pro interakci s uživatelem může být spuštěna ještě před tím, než přijdou data. Až přijdou data, coroutina opět poběží a na základě získaných dat aktualizuje UI pomocí funkce \lstinline|updateUi()|. Klíčové slovo \lstinline|suspend| u deklarace funkce znamená, že je suspendovatelná a lze z ní volat funkce, které jsou také suspendovatelné.

\begin{lstlisting}[caption={Praktický příklad použití coroutiny}, label={lst:coroutine-practical}, tabsize=2]
fun main() = runBlocking {
	launch {
		val data = fetchDataFromApi()
		updateUi(data)
	}
	handleUserInteraction()
}

suspend fun fetchDataFromApi() {...}
\end{lstlisting}

\noindent Výhoda coroutines oproti vláknům je tedy menší paměťová náročnost a menší zátěž na procesoru.

\vspace*{10px}

\noindent \textbf{Kotlin Flow} - Pro zvýšení čitelnosti a expresivnosti kódu a implementaci stránkování je v aplikaci používán datový typ Kotlin Flow, který reprezentuje sekvenci hodnot, které jsou produkovány a konzumovány asynchronně pomocí suspend funkcí. Příkladem použití je získání aktuálního volebního roku každou sekundu (\ref{lst:flow-general}).

\begin{lstlisting}[caption={Příklad použití flow}, label={lst:flow-general}, tabsize=2]
              
fun fetchData(): Flow<Int> = flow {
	while(true) {
		val year = fetchLatestElectionYear()
		emit(year)
		delay(1000)
	}
}

fun main() = {
	fetchData().collect { data -> println(data) } 
}
\end{lstlisting}

\noindent Funkce \lstinline|flow| vytvoří flow, který v nekonečném cyklu získá data, emitne je a počká 1 s, než postup zoopakuje. Vidíme tedy, že funkce \lstinline|emit| vrací data, ale funkce pokračuje dál. Funkce skončí až tehdy, kdy doběhne na konec. Funkce vrací flow, v tuto chvíli však kód dané flow ještě neběží. Až po zavolání funkce \lstinline|collect| začne flow provádět svůj kód a emitovat data. Takovým funkcím, které spustí kód ve flow říkáme terminální operátory. Terminální operátor konzumuje všechny hodnoty emitované danou flow, s kterými lze dále pracovat. Výhodou kotlin flow je tedy jednoduchá implementace pro zpracovávání potenciálně nekonečných streamů dat, které jsou produkovány a konzumovány asynchronním způsobem pomocí coroutinů.

Další výhodou kotlin flowů je možnost použití tzv. \textit{intermediate} operátorů, které s hodnoty emitované flowem nějakým způsobem manipulují. Mohou je např. filtrovat, mapovat na jiné hodnoty, kešovat je a další. V (\ref{lst:flow-intermediate}) voláme funkci, \lstinline|getMembers()|, která vrací flow Votů. Na ní se zavolá intermediate operátor \lstinline|filter|, který z hodnot emitovaných danou flow vyfiltruje takové voty, jejichý popis začíná písmenem A. V tuto chvíli flow ještě neběží. Následně se zavolá terminální operátor \lstinline|collect|, který flow spustí a zkonzumuje.

Kotlin flows se používají také pro implementaci stránkování, které bude poposáno v sekci Implementace uživatelského rozhraní.

\begin{lstlisting}[caption={Příklad intermediate operátoru pro flow}, label={lst:flow-intermediate}, tabsize=2]
fun main() = {
	getVote()
		.filter(vote -> vote.description.startsWith("A"))
		.collect { vote -> updateUi(vote)
	}

	fun getVote(): Flow<Vote> {...}
}
\end{lstlisting}

\subsubsection *{Android komponenty}
Aplikace v Androidu jsou složeny z Android komponentů, které mají na starosti různé odpovědnosti:

\begin{itemize}
	\item Application - Reprezentuje celou aplikaci. V rámci práce je používaná pouze pro nakonfigurování DI pomocí Hiltu, které bude popsáno v následující sekci.
	\item Activity - Reprezentuje obrazovku. Je to vstupní bod pro vytvoření UI a pro počáteční inicializace.
	\item ViewModel - Reprezentuje komponentu, která definuje business logiku a drží si stav UI elementů. Změna stavu komponenty ViewModel způsobí i změnu UI. ViewModel si pamatuje data i po konfiguračních změnách (např. otočení mobilu).
\end{itemize}

\subsubsection *{Hilt}
Hilt je DI knihovna pro Android. Poskytuje kontejnery pro každou Android komponenty. Tyto kontejnery spravují objekty a jejich závislosti a jsou použity pro injektování závislostí. Příkladem injektování kódu lze vidět na (\ref{lst:hilt}). Do třídy \lstinline|GetAppStateUseCase| injektujeme pomocí anotace \lstinline|@Inject| implementataci rozhraní \lstinline|AppStateRepository|.

\begin{lstlisting}[caption={Příklad použití DI pomocí knihovny Hilt}, label={lst:hilt}, tabsize=2]
class GetAppStateUseCase @Inject constructor(
	val appStateRepository: AppStateRepository,
) {...}

interface AppStateRepository {...}
\end{lstlisting}

\noindent Pro konfiguraci závislostí, na základě kterého Hilt sestaví kontejnery, jsou používány tzv. moduly - objekty pro konfiguraci závislostí. V konfigurace (\ref{lst:hilt-module}) říkáme, že do proměnných typu \lstinline|AppStateRepository| budou injektován objekt \lstinline|AppStateRepositoryImpl|. Objekt je přiom instanciován jako singleton. Objekt zároveň potřebuje závislost na \lstinline|PspRemoteDataSource|, který musí být opět někde nakonfigurován, aby tu mohl být injektován. Buď v tom samém modulu nebo v jiném, pokud chceme moduly pro čitelnost nějakým způsobem rozdělit.

\begin{lstlisting}[caption={Příklad konfigurace závislostí pro Hilt}, label={lst:hilt-module}, tabsize=2]
@Module
@InstallIn(SingletonComponent::class)
object DataModule {
	
	@Provides
	fun provideAppStateRepository(
	pspRemoteDataSource: PspRemoteDataSource
	): AppStateRepository {
		return AppStateRepositoryImpl(pspRemoteDataSource)
	}

}
\end{lstlisting}
	
zdroj: https://kotlinlang.org/docs/flow.html
zdroj: https://kotlinlang.org/docs/object-declarations.html
zdroj: https://kotlinlang.org/docs/null-safety.html
zdroj: https://kotlinlang.org/
zdroj: https://techcrunch.com/2019/05/07/kotlin-is-now-googles-preferred-language-for-android-app-development/
zdroj: zdroj: https://www.oracle.com/java/
zdroj: https://developer.android.com/kotlin/coroutine

\subsection {Implementace uživatelského rozhraní}
V této sekci bude popsána implementace uživatelského rozhraní.

\subsubsection*{Jetpack Compose}
\label{sssec:jetpack-compose}
Jetpack Compose je Androidem doporučený způsob pro implementaci uživatelského rozhraní. Rozhraní je implementováno voláním tzv \textit{composable} funkcí, což jsou funkce anotované anotací @composable a reprezentují nějaký UI element na obrazovce. Jetpack Compose nám již poskytuje nativní UI elementy jako text a tlačítko nebo kontejnery pro seskupení element do řádku či sloupců. Tyto nativní UI elementy lze kombinovat, a tím vytvořit složitější komponenty. Tyto složitější komponenty lze pak zapouzdřit do vlastně definované composable funkce. Důsledkem je to, že celé UI popisováno pomocí composable funkcí, které volají další composable funkce. Díky tomu je kód pro vytvoření UI modulární. 

Jelikož composable funkce jsou vlastně jenom funkce napsané v programovacím jazyce, lze jim předávat parametry, které určují vzhled či chování daného UI elementu. Které parametry composable funkce přijímá a co určuji závisí na implementaci dané funkce. Jsou parametry, které mění např. barvu a velikost daného elementu. Dále jsou parametry, kterým předáváme funkci. Tato funkce může být volána např. když je na daný element kliknuto. Také jsou parametry, které určují textový obsah nějakého textového elementu. Výhodou použití knihovny Jetpack Compose je možnost definovat UI pomocí programovacího jazyka. To znamená, že lze využít cykly (např. pro vytvoření seznamu elementů) nebo podmínky (např. pro podmíněné vykreslování). Implementace rozhraní je díky tomu jednoduchá a intuitivní.

Alternativou k Jetpack Composu jsou XML layouty, které k popisu UI používají externí XML soubor, kde je rozhraní popisováno pomoxí XML tagů a jejich atributů. Hlavní myšlenkou tohoto přístupu je to, že oddělujeme popis uživatelského rozhraní od programového kódu, díky čemuž je kód čitelnější a udržitelnější. Míchání popisu UI a programového kódu se však nikdy nevyhneme, jelikož layoutům se musí minimálně předat aspoň data. Toho lze dosáhnout pouze propojením programového kódu s layoutem. Pokud implementujeme dynamický seznam, situace pro XML layouty je ještě horší, neboť implementace vyžaduje hodně boilerplate kódu. Pro Jetpack Composu je vytvoření takového seznamu otázkou pár řádků kódu.

Z výše uvedených důvodů jsem se rozhodl uživatelské rozhraní implementovat pomocí Jetack Compose.

\vspace*{10px}
\noindent zdroj: https://developer.android.com/develop/ui/views/layout/recyclerview
\noindent zdroj: https://developer.android.com/jetpack/compose/lists
zdroj: https://developer.android.com/jetpack/compose

\vspace*{10px}

\subsubsection*{Composable funkce}
Základním stavebním kamenem pro tvorbu uživatelského rozhraní pomocí knihovny Jetpack Compose jsou composable funkce. V (\ref{lst:jc-text}) lze vidět použití nativní composable funkce \lstinline|Text|, která slouží pro vytvoření textového UI elementu. Vidíme, že funkce přijímá parametr \lstinline|text|, který určuje textový obsah.

\begin{lstlisting}[caption={Příklad použití composable funkce Text.}, label={lst:jc-text}]
Text(text = "Vysledky hlasovani")
\end{lstlisting}

\noindent Composable funkce lze kombinovat pro vytvoření složitějších composable funkcí (\ref{lst:jc-combine}). Vytváříme zde ikonku pomocí funkce \lstinline|Icon| a text. Ikonka přijímá parametr specifikující objekt reprezentující danou ikonku a text používaný pro přístupové služby. Oba elementy jsou pak seskupeny do řádku pomocí kontejnerové composable funkce \lstinline|Row|.

\begin{lstlisting}[caption={Příklad skládání composable funkcí. Vykreslí ikonku a text vedle sebe.}, label={lst:jc-combine}, tabsize=2]
Row {
	Icon(
		imageVector = Icons.Filled.ArrowBack,
		contentDescription = "Tlacitko zpet",
	)
	Text(text = "Detail hlasovani)
}
\end{lstlisting}

\noindent Pomocí parametrů lze měnit i vzhled a chování composable funkce. (\ref{lst:jc-parameters}). Vytváříme zde tlačítko  s textem a černým okrajem, které při kliknutí vypíše do konzole text.

\begin{lstlisting}[caption={Příklad parametrů pro změnu vzhledu a chování.}, label={lst:jc-parameters}, tabsize=2]
Button(
	onClick = { println("Kod pro ulozeni") },
	border = BorderStroke(0.dp, Color.Black)
) {
	Text(text = "Ulozit")
}
\end{lstlisting}

\vspace*{10px}

\subsubsection*{Kompozice a rekompozice}
Kompozice funkce je proces, kdy se zavolá. Rekompozice funkce je pak proces, kdy se zavolá znovu v reakci na změnu jejího lokálního stavu nebo stavu ve ViewModelu, na kterém je závislý, nebo na rekompzici rodiče. Lokální stav composable funkce je popsána v následující sekci. Důsledkem je to, že změna composable funkce (jejího stavu) spustí rekompozici pouze této funkce a všech funkcí, které volá. Ostatní funkce zůstanou nedotčené. Díky tomu dojde k rekompozici pouze u funkcí, kde se něco změnilo nebo potěnciálně změnilo.

\vspace*{10px}

\subsubsection*{Stav composable funkce}
Composable funkce mohou v sobě držet lokální stav. Kód (\ref{lst:jc-state}) ukazuje příklad jeho použití. Zde vidíme text a tlačítko. Text se vykresluje podmíněně podle aktuální hodnoty proměnné \lstinline|expanded|. Defaultní hodnota proměnné \lstinline|expanded| je \lstinline|false|, a tudíž při první kompozici funkce se text nevykreslí. Tlačítko v reakci na kliknutí této proměnné nastaví opačnou hodnotu, což spustí rekompozici funkce. Aby změna této proměnné spustila rekompozici, musí být typu \lstinline|State|. Aby se proměnná však vůbec dala měnit, musí být typu \lstinline|MutableState|, a proto je defaultní hodnota \lstinline|false| obalena do funkce \lstinline|mutableStateOf|. Aby se při rekompozici nenastavila opět defaultní hodnota \lstinline|false|, ale nová hodnota, musí si composable funkce tento stav pamatovat napříř rekompozicemi, a toho dosáhneme pomocí funkce \lstinline|remember|. Klíčové slovo \lstinline|by| je syntactic sugar, který deleguje vrácení hodnoty na funkci \lstinline|remember|. Pro nás to znamená jenom to, že typ proměnné \lstinline|expanded| je Boolean a ne State<Boolean>. Pracuje se s tím pak lépe. 

\begin{lstlisting}[caption={Příklad composable funkce používající lokální stav.}, label={lst:jc-state}, tabsize=2]
	@Composable
	private fun MyExpandableContent() {
		var expanded by remember {mutableStateOf(false)}
		
		Row {
			if (expanded) {
				Text(text = "Zbytek obsahu")
			}
			Button(onClick = { expanded = !expanded },
			) {
				Text(text = "Klikni pro zobrazeni zbytku obsahu")
			}
		}
	}
\end{lstlisting}

\noindent Mnohem obvyklejší je však stav zapouzdřit do ViewModelu, který je určený k ukládání stavu UI, jak je ukázáno na (\ref{lst:jc-viewmodel}). ViewModel si pamatuje stav i při navigaci na jinou obrazovku a zpět. Díky může data stažená např. z internetu přepoužít a nemusí je zbytečně stahovat vícekrát, pokud se data málo mění.

\begin{lstlisting}[caption={Příklad composable funkce používající stav z ViewModelu.}, label={lst:jc-viewmodel}, tabsize=2]
@Composable
private fun MyExpandableContent(viewModel: MyViewModel) {
    val expanded = viewModel.expandeed

		Row {
			if (expanded) {
				Text(text = "Zbytek obsahu")
			}
			Button(onClick = { viewModel.toggleExpanded() },
			) {
				Text(text = "Klikni pro zobrazeni zbytku obsahu")
			}
		}
}

class MyViewModel : ViewModel() {
	val expanded = mutableStateOf(false)
	
	fun toggleExpanded() {
		expanded = !expanded
	}
}
\end{lstlisting}

\noindent zdroj:
https://developer.android.com/jetpack/compose/mental-model

\subsubsection*{Activity}
Aktivita je jedna z hlavních komponent aplikace a reprezentuje obrazovku, do které vkládáme naše uživatelské rozhraní. V rámci aplikace je použita především jako vstupní bod pro vytvoření UI a pro počáteční inicializace stavu aplikace. Aktivita se může nacházet v různých stavech podle toho, zda ji má uživatel v popředí nebo pozadí, nebo zda ji vypíná. Nás bude zajímat především stav, kdy je aktivita poprvé vytvořena, tedy když je aplikace spuštěna. Pro detekci tohoto stavu poskytuje aktivita funkci \lstinline|onCreate|, která se zavolá, když je aktivita vytvořena. V této funkci lze pak provádět žádané operace (\ref{lst:main-activity}). Funkce \lstinline|setcontent| vezme composable funkci \lstinline|PspApp|, zakomponuje ji do aktuální aktivity a nastaví ji jako kořenovou composable funkci.

\begin{lstlisting}[caption={Třída MainActivity. (Soubor \lstinline|psp_fe/app/MainActivity|}), label={lst:main-activity}, tabsize=2]
class MainActivity : ComponentActivity() {

	...
	
	override fun onCreate(savedInstanceState: Bundle?) {
		super.onCreate(savedInstanceState)
		
		...
		
		setContent {
			PspApp()
		}
	}

	...
\end{lstlisting}

\subsection {Implementace prezentační vrstvy}
\label{sssec:impl-ui}
Popis implementace prezentační vrstvy je rozděleno na popis implementace uživatelského rozhraní a popis implementace držitelů stavů a logiky. Nejdřív bude popsána první implementace a po ní druhá. 

Uživatelské rozhraní bylo implementováno pomocí knihovny Jetpack Compose. Pro implementaci byly použity následující composable funkce:

\begin{itemize}
	\item Column - Sloupcový kontejner pro elementy. Hodí se pro pozicování UI elementů na obrazovce. Nehodí se pro dlouhé seznamy elementů ve sloupci, jelikož nedělá rekompozici pouze viditelných elementů, ale všech. Nejde jím scrollovat. Používám ji ve všech místech, kde je potřeba napozicovat UI elementy pod sebou.
	\item LazyColumn - Sloupcový kontejner pro element zoptimalizovaný pro dlouhé seznamy. Dělá rekompozici pouze pro viditelné elementy. Lze jím scrollovat. Používám ji pro zobrazení seznamů, tedy na obrazovce pro seznam hlasování, seznam poslanců, seznam hlasování jednotlivých klubů a seznam hlasování poslance.
	\item Row - Řádkový kontejner pro elementy.
	\item Text - Textový element.
	\item Image - Obrázkový element. Obrázek lze získat pomocí URL adresy. Používám ho pro zobrazení profilové fotky poslance a logů klubů.
	\item Icon - Funkce pro různé ikonky, např. pro ikonky v hlavičce nebo v dolní liště.
	\item IconButton - Tlačítko, který má místo textu ikonky. Používám ji hlavičce pro vytvoření ikonky pro vyhledávání v seznamu hlasování nebo poslanců.
	\item OutlinedButton - Tlačítko s kontrastem barev mezi pozadím a obvodem.
	\item OutlinedTextField - Textové pole s kontrastem barev mezi pozadím a obvodem.
	\item FloatingActionButton - Plovoucí tlačítko. Používám ji pro skok na začátek seznamu.
	\item Scaffold - Kontejner umožňující jednoduchým způsobem sdílet UI element mezi více obrazovkami. Umožňuje také jednoduchým způsobem přidat plovoucí tlačítko.
	\item TopAppBar - Horní lišta.
	\item Spacer - Vytváří mezeru mezi dvěma UI elementy. zda je mezera horizontální nebo veritkální, specifikujeme skrz parametr.
	\item Divider - Oddělovač. Dá se nastavit na vertikální nebo horizontální.
	\item CompositionLocalProvider - Umožňuje přepsat hodnotu kontextu. Používám ji pro lokální přepsání globálních barev.
	\item Box - Kontejner umožňující skládat UI elementy na sebe. Používám ho pro vytvoření popupu s nastavením volebního období v nastavení. Na pozadí je seznam nastavení a na něm se objeví daný popup.
	\item SettingsMenuLink - Composable funkce z knihovny Alorma pro snadné vytvoření prvku v seznamu nastavení přesně podle návrhu. Knihovna ji definuje defaultní vzhled.
	\item ListItemPicker - Composable funkce z knihovny Alorma reprezentující seznam hodnot, kterým lze scrollovat. Knihovna ji definuje defaultní vzhled.
	\item Card - Karta obsahující libovolný obsah a prvek pro akci. Používám ji např. pro elementy v seznam hlasování.
	\item TabRow - Lišta s taby. Používám ji na obrazovce s detailem hlasování a na obrazovce s detailem poslance.
	\item Tab - Reprezentuje konkrétní obrazovku v rámci tabu.
	\item HorizontalPager - Layout umožňující horizontálne scrollovat obsahem. Používám ho pro scrollování mezi taby.
\end{itemize}

\vspace{10px}

\noindent Stav UI a logika pro obsluhu změn UI jsou zapouzdřeny v držitelích stavů a logiky, což jsou view modely. Jsou to objekty, s kterými komunikuje Jetpack Compose pro získání dat nebo pro informování o nějaké události. Na (\ref{lst:view-model}) lze vidět ukázku využití view modelu. Na začátku view modelu se nachází stav pro seznam hlasování. \lstinline|PagingData| je datový typ pro stránkovaný obsah. \lstinline|MutableStateFlow| je datový typ pro flow, který lze měnit. Flow je vyžadován pro implementaci stránkování pomocí \lstinline|PagingData|. Vně view je viditelná pouze imutabilní verze stavu \lstinline|StateFlow|. Pro bezpečnost se se stavem dá manipulovat pouze uvnitř view modelu. Při spuštění view modelu se proveden coroutinová operace v rámci scopu view modelu. To znamená, že pokud je view model odstraněn, zruší se i coroutinová operace. Coroutina získává data pomocí funkce \lstinline|getVotes|. Ta vyžaduje volební rok a klíčová slova pro filtrování seznamu. Jakmile se změní jedna z těchto dvou hodnot, měly by se stáhnout nová data. Obě hodnoty jsou implementeovány jako flow, a proto je nejdřív kombinujeme a zavoláme na nich terminální operátor \lstinline|collectLatest|. Emitované hodnoty se pomocí \lstinline|cachedIn(viewModelScope)|zakešují v rámci view modelu. To znamená, že pokud se na daném flow opět zavolá terminální operátor v jiné části kódu, vrátí se zakešovaná hodnota. 

\begin{lstlisting}[caption={Ukázka využití view modelu}, label={lst:view-model}, tabsize=2]
// Soubor VoteListViewModel.kt
class VoteListViewModel(
...
): ListViewModel(...) {
	
	private val _votes: MutableStateFlow<PagingData<Vote>> =
	MutableStateFlow(PagingData.empty())
	val votes: StateFlow<PagingData<Vote>> = _votes
	
	init {
		viewModelScope.launch {
			currentElectionYear.combine(searchText, ::Pair)
			.collectLatest { pair ->
				getVotes(pair.first, pair.second)
				.cachedIn(viewModelScope)
				.collect { votes ->
					_votes.value = votes
				}
				
			}
		}
	}
	
}
\end{lstlisting}

\vspace{10px}

\noindent Navigace mezi obrazovkami je implementována pomocí composable funkce \lstinline|NavHost|, která definuje jednotlivé destinace. Destinace reprezentuje obrazovku, ke které lze pomocí této funkce navigovat. Destinace je reprezentována řetězcem. Např. destinace pro seznam hlasování se nazývá "votes". Pro samotnou navigaci se používá objekt \lstinline|NavHostController|, na které zavoláme metodu \lstinline|navigate| a předáme ji název destinace, ke které chceme navigovat. Pro navigaci k detailu hlasování nebo poslance používá sepcifičtější název destinace, např. "votes/1234" nebo "member/5678".

\subsection {Implementace doménové vrstvy}
Ukázka implementace doménové vrstvy pro seznam hlasování (\ref{lst:use-case-vote}). Objekt \lstinline|Pager| je vstupním bodem pro stránkovací mechanizmus. Nastavujeme mu defaultní velikost stránky, v době psaní práce je to 20. Dále mu předáme \lstinline|VotesPagingSource| reprezentující zdroj stránkovaných dat. Pager poskytuje proměnnou flow, která bude emitovat stránky. \lstinline|flowOn| nastaví, aby sbírání flow probíhalo na speciálním vlákně IO, aby neprobíhalo na hlavním vlákně. Není to nutné díky používání coroutinů, ale je to dobrá praxe to používat pro síťové operace.

\begin{lstlisting}[caption={Ukázka využití use caseu pro získání seznamu hlasování}, label={lst:use-case-vote}, tabsize=2]
// Soubor GetVotesUseCase.kt
class GetVotesUseCase @Inject constructor(...) {
	
	operator fun invoke(electionYear: Int, searchText: String) = Pager(
		PagingConfig(pageSize = DEFAULT_PAGE_SIZE)
	) {
		VotesPagingSource(
			voteRepository = voteRepository,
			electionYear = electionYear,
			searchText = searchText
		)
	}
	.flow
	.flowOn(Dispatchers.IO)
	
}
\end{lstlisting}

\noindent Doménové vrstvy pro obrazovky, které nepoužívají seznam, jsou přímočařejší. Ukázku takového use caseu lze vidět na (\ref{lst:use-case-vote-detail}).

\begin{lstlisting}[caption={Ukázka využití use caseu pro získání detailu hlasování}, label={lst:use-case-vote-detail}, tabsize=2]
// Soubor GetVoteDetailUseCase.kt
class GetVoteDetailUseCase @Inject constructor(...) {
	
	operator fun invoke(id: Int): Flow<VoteDetails> =
		voteRepository.getVoteDetail(id)
		.flowOn(Dispatchers.IO)	
}
\end{lstlisting}

\subsection {Implementace datové vrstvy}
Datová vrstva slouží pro abstrahování doménové vrstvy od konkrétních datových zdrojů. V aplikaci je použit jediný datový zdroj, a to vzdálený pro získání data z backendu. V datové vrstvě jsou získávána data z datového zdroje v podobě síťových entit. Ty jsou následně namapována na doménové entity pro použití doménovou vrstvou. Ukázka použití je na (\ref{lst:use-case-repository}).

\begin{lstlisting}[caption={Ukázka datové vrstvy pro data o hlasováních}, label={lst:use-case-repository}, tabsize=2]
class VoteRepositoryImpl @Inject constructor(...) : VoteRepository {
	
	override suspend fun getVotes(
		page: Int,
		size: Int,
		electionYear: Int,
		searchText: String
	): List<Vote> =
	pspRemoteDataSource.getVotes(
		page = page,
		size = size,
		electionYear = electionYear,
		searchText = searchText
	).map { it.toDomain() }
	
	...
}
\end{lstlisting}

\vspace{10px}
\noindent Datové zdroje jsou pouze abstrakcí nad konkrétním rozhraním pro získání daného zdroje. Vzdálený datový zdroj tedy abstrahuje datovou vrstvu od přímé komunikace s knihovnou pro získání dat z internetu. Na (\ref{lst:data-source}) je ukázka datového zdroje. Funkce \lstinline|getAppState()| pouze zavolá funkci definovanou pomocí knihovny Retrofit, která bude popsána v následující sekci.

\begin{lstlisting}[caption={Ukázka datového zdroje}, label={lst:data-source}, tabsize=2]
class PspRemoteDataSourceImpl @Inject constructor(
	private val pspApi: PspApi
) : PspRemoteDataSource {
	
	override suspend fun getAppState() = 
		pspApi.getAppState()
		
	...
}
\end{lstlisting}

\subsection{Implementace síťové vrstvy}

\noindent Síťová vrstva je implementována pomocí knihovny Retrofit. Je to HTTP klient pro komunikaci se zdroji na internetu. Aplikaci ho používá pro získání veškerých dat z backendu. Na (\ref{lst:retrofit-votes}) je ukázka použití. URL adresu daného zdroje specifikujeme pomocí anotace \lstinline|@GET|. Pomocí anotací \lstinline|Query| specifikujeme query parametry pro jako číslo stránky a počet stránek. Návratovou hodnotou je seznam API entit. Implementaci této funkce má na starosti knihovna. Data z backendu jsou ve formátu JSON a jsou namapována na objekt v návratovém typu.

\begin{lstlisting}[caption={Ukázka použití knihovny Retrofit pro získání seznamu hlasování z backendu}, label={lst:retrofit-votes}, tabsize=2]
interface PspApi {
	
	@GET("/api/vote")
	suspend fun getVotes(
		@Query("page") page: Int,
		@Query("size") size: Int = DEFAULT_PAGE_SIZE,
		@Query("sortBy") sortBy: String = DEFAULT_VOTE_SORT_BY,
		@Query("order") order: String = DEFAULT_ORDER,
		@Query("electionYear") electionYear: Int
	): List<VoteApiEntity>
	
}
\end{lstlisting}

zdroj: https://square.github.io/retrofit/

\section{Backend}

\subsection {Použité nástroje a technologie}
\subsubsection*{Intellij IDEA}
Backend byl vyvíjen ve vývojovém prostředí Intellij IDEA. Hlavní důvody pro výběr tohoto IDE:

\begin{itemize}
	\item Vestavěný inicializátor Spring Boot aplikací - Pomocí tohoto inicializátor lze nakonfigurovat a nastavit potřebné závislosti ve Spring Boot\footnote{Technologie Spring Boot bude popsána později.} aplikaci jednoduše naklikáním v průvodci.
	
	\item Klávesové zkratky - Toto IDE je vyvíjeno společností JetBrains, a tudíž obsahuje stejné klávesové zkratky jako Android Studio.
\end{itemize}

zdroj: https://www.jetbrains.com/idea/

\subsubsection*{Maven}
Maven je stejně jako Gradle nástroj pro automatizaci sestavování programu. Původně byl použit Gradle kvůli čitelnější syntaxi. Maven byl zvolen z historických důvodů. Původně bylo v plánu backend nasadit na Cloud Azure. Ten poskytoval plugin pro maven, který umožňoval backend nasadit a zprovoznit pomocí jednoho příkazu. Kvůli omezeného free tieru však byl backend nakonec nasazen na jiný cloud (více v kapitole o nasazení). Maven je tedy pozůstatek historického rozhodnutí. Na funkčnosti aplikace to však nemá žádný vliv, a proto se už nepřešlo z Mavenu na Gradle. 

zdroj: https://maven.apache.org/

https://azure.microsoft.com/en-us

\subsubsection*{Spring Boot}
Před popisem technologie Spring Boot si popíšeme technologii Spring, na které je Spring Boot založen. Spring je open-source framework pro vývoj enterprise aplikací. Je to seskupení různých nástrojů pro řešení různých problémů. Pro účely této práce byly využity nástroje pro vytvoření webových aplikacím, ale umožňují implementovat i backend s REST API. Hlavními benefity Springu je množství použitelných nástrojů a dependency injection pomocí anotací.

Spring Boot je framework, který je postavený na Springu a který má za cíl redukci boilerplate kódu a nutnost konfigurace, a tím urychlit vývoj aplikace. Toho dosahuje pomocí autokonfigurace, což je vlastnost Spring Bootu, kdy jsou jednotlivé komponenty (např. rozhraní pro komunikaci s databází, webový server, ORM) automaticky nakonfigurovány Spring Bootem pomocí defaultních hodnot. Defaultní hodnoty jsou Spring Bootem nastaveny na nejčastější hodnoty, aby se tím pokrylo co nejvíce situací, na které může vývojář narazit. Důsledkem je to, že pro zprovoznění komponent je potřeba pouze nainstalovat jejich závislost. Pokud bude potřeba použít jinou konfiguraci (např. pro připojení k databázi chceme použít jiný než defaultní port), Spring Boot to umožňuje. Pointa je však, že knihovnu pouze stáhneme bez nutnosti konfigurace nebo s minimální konfigurací a aplikace lze hned spustit.

Alternativou ke knihovně Spring Boot je knihovna Ktor, pomcí které lze taktéž vytvořit backend s REST API. Výhodou této knihovny je, že je určená pro psaní v Kotlinu. Lze tedy využít všechny výhody tohoto jazyka. Nevýhodou je, že nepodporuje defaultně dependency injection. Pro něj se musí zvlášť stáhnout knihovna a a tu nakonfigurovat. Další nevýhodou oproti Spring Bootu je chybějící autokonfigurace. Vše se tedy musí manuálně nakonfigurovat.

zdroj:

https://spring.io/

https://spring.io/why-spring

https://spring.io/web-applications

https://ktor.io/

\subsubsection*{Java}
Java byla od začátku hlavním programovacím jazykem pro vývoj aplikací pomocí technologie Spring Boot. Od roku 2017 přišla integrace jazyka Kotlin do Spring Bootu a v dokumentaci jsou ukázkové kódy psány jak v Javě tak i Kotlinu. Java má oproti Kotlin větší podporu v komunitě, co se týče vývoji ve Spring Bootu. Když jsem při psaní v Javě narazil na nějaký problém, mnohem šlo najít na internetu řešení než při psaní v Kotlinu. Jedním řešením je hledat řešení v Javě a javovský kód pomocí automatického nástroje ztransfomovat do Kotlinu, výsledný kód bylo však potřeba vždy prošistit, jelikož u všech proměnných vždy obsahoval datové typy, které lze v Kotlinu v některých případech vynechat. Zároveň výstupní kód někdy nebyl kvůli nějaké drobnosti kompilovatelný. Z toho důvodu jsem se rozhodl pro použití Java. Zdá se však, že podpora pro psaní aplikací Spring Boot pomocí Kotlinu je čím dál tím větší. Když bych měl možnost backend přepsat, znovu bych zauvažoval o použití Kotlinu, jelikož je to velmi dobrý programovací jazyk.

zdroj:
 https://spring.io/guides/tutorials/spring-boot-kotlin/

https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0

zdroj:

https://docs.spring.io/spring-boot/docs/current/reference/html/index.html\textbf{}

\subsubsection*{MySQL}
Na databázi backendu nebyly kladeny velké nároky. Pouze bylo potřeba data perzistentní uložit, aby byly připravené pro použití mobilní aplikací. Zvolil jsem tedy MySQL, s kterým jsem měl zkušenosti. Bylo by však možné použít např. i PostreSQL. Na funkčnosti backendu by to však nemělo vliv.

\subsection {Prezentační vrstva}
V prezentační vrstvě byly implementovány jednotlivé endpointy REST API, které přijímají dotazy od mobilní aplikace a vrací ji předzpracovaná data uložena v databázi. Ukázku implementace endpointu pro získání detailu konkrétního hlasování lze vidět na (\ref{lst:controller-votes}). Endpoint pro HTTP GET požadavky je ve Spring Bootu implementován tak, že vytvoříme metodu s libovolným názvem a označíme ji anotací \lstinline|@GetMapping|. V parametru této anotace pak specifikujeme URL adresu daného endpointu. Celá metoda se musí nacházet ve tříde s anotací \lstinline|@RestController|. Endpointy jsou rozděleny do několika tříd podle typu dat (jedna třída pro entity hlasování, druhá pro entity poslance a třetí pro entity klubů). Pokud URL adresa obsahuje parametr identifikující daný zdroj, musí být obsažen v parametru metody a oanotován pomocí \lstinline|@PathVariable|

\begin{lstlisting}[caption={Ukázka kódu pro vytvoření endpointu}, label={lst:controller-votes}, tabsize=2]
// Soubor VoteController.java
@RestController
public class VoteController {
	
	private final VoteService service;
	private final VoteMapper mapper;
	
	...
	
 	@GetMapping("/vote/{id}")
	public DetailedVote getVote(@PathVariable Integer id) {
		Vote vote = service.getVote(id);
		return mapper.toDetailedVote(vote);
	}

\end{lstlisting}

\noindent Query parametry jsou implementovány pomocí anotace \lstinline|RequestParam|, kterému je v parametru předán název parametru: 

\begin{lstlisting}[caption={Ukázka endpointu s request parametrem}, label={lst:request-param}, tabsize=2]
// Soubor VoteController.java
@RestController
public class VoteController {
	
	private final VoteService service;
	private final VoteMapper mapper;
	
	...
	
	@GetMapping("/vote")
	public ResponseEntity<List<GeneralVote>> getVotes(
		@RequestParam(name = "description") String description
		...
	) {
		...
	}
}
\end{lstlisting}

\noindent Podobným způsobem jsou implementovány query parametry pro stránkování (číslo a velikost stránky). Kromě povinného parametru pro název query parametru lze specifikovat i parametr \lstinline|required| pro nastavení volitelnosti nebo  \lstinline|defaultValue| pro nastavení defaultní hodnoty query parametru.

\vspace{10px}
\noindent Na dvou předchozích ukázkách lze vidět použití hodnot \lstinline|service| a \lstinline|mapper|. První reprezentuje doménovou vrstvu, která získá data z databázové vrstvy a druhá obsahuje metody pro mapování objektů, pokud je to potřeba (pokud je struktura entit uložených v databázi jiná než struktura entit pro REST API). Takto jsou implementovány všechny controllery. Controllery, které obsahují endpoint, který vrací seznam, navíc sestavují hlavičky pro HTTP odpověď. K tomu je použita třída \lstinline|HttpHeaders|, kterou poskytuje Spring framework. Instanci této třídy se jednoduchým způsobem nastaví potřebné hodnoty a objekt je controllorem vracen:

\begin{lstlisting}[caption={Ukázka nastavení hlaviček pro stránkování}, label={lst:headers-paging}, tabsize=2]
// Soubor PaginationHeaderGenerator.java
public static HttpHeaders buildHeaders(...) {
	HttpHeaders responseHeaders = new HttpHeaders();

	...
	
	responseHeaders.set(previousPageString, String.valueOf(prevPage));
	responseHeaders.set(nextPageString, String.valueOf(nextPage));
	responseHeaders.set(lastPageString, String.valueOf(lastPage));
	
	return responseHeaders;
}

// Soubor VoteController.java
@GetMapping("/vote")
public ResponseEntity<List<GeneralVote>> getVotes(...) {

	...
	
	HttpHeaders headers = GenericAndPaginationHeaderGenerator
		.buildHeaders(pagedResult.getTotalPages(), page);
	
	...	
	
	return ResponseEntity
		.ok()
		.headers(headers)
		.body(generalVotes);
}
\end{lstlisting}

\subsection {Doménová vrstva}
Doménová vrstva má na starosti business logiku aplikace a abstrahování prezentační vrstvy od implementačních detailů databázové vrstvy. V našem případě backend neobsahuje business logoiku, pouze filtruje data. Ukázka kódu pro získání detailu poslance:

\begin{lstlisting}[caption={Ukázka kódu pro získání detailu poslance}, label={lst:headers-paging}, tabsize=2]

// Soubor MemberService.java
public Member getMember(int id) {
	return memberRepository
	.findById(id)
	.orElseThrow(() -> new MemberNotFoundException(id));
}
	
\end{lstlisting}

\noindent Pro získání seznamů je použito stránkování, které je implementováno pomocí třídy \lstinline|Pageable|. Ta se předá repozitáři, který bude popsán v následující sekci:

\begin{lstlisting}[caption={Ukázka doménové vrstvy pro vrácení seznamu poslanců}, label={lst:headers-paging}, tabsize=2]

// Soubor MemberService.java
public Page<Member> getMembers(PagingParams pagingParams) {
	
	Pageable pageable = PageableGenerator.buildPageable(pagingParams);
	
	if (filterName == null) {
		return memberRepository
			.findByElectionYear(electionYear, pageable);
	} else {
		// kod pro filtrovani poslancu
	}
}
\end{lstlisting}

\noindent Instance třídy \lstinline|Pageable| je vytvořena následovně:

\begin{lstlisting}[caption={Ukázka kódu pro sestavení objektu pro stránkování}, label={lst:paging-object}, tabsize=2]
	
public static Pageable buildPageable(...) {
	Pageable pageable;
	
	...
	
	pageable = PageRequest.of(page, size, sort);
	// napr. page = 2, size = 20, sort = Sort.by("dateTime").descending())
	
	return pageable;
}

\end{lstlisting}

\noindent Doménová vrstva pro ostatní entity jsou implementovány obdobně jako bylo popsáno výše. Výjimkou je metoda pro získání detailu hlasování. Jedním z atributů hlasování jsou statistky hlasování. Výpočet počtu omluvených a nepřihlášených poslanců příliš zpomalovalo zpracování zdrojových dat přes uložením do databáze. Z toho důvodu je tento výpočet prováděn až za běhu, kdy se mobilní aplikace nad daným detailem hlasování dotazuje:

\begin{lstlisting}[caption={Ukázka dopočtu statistik pro detail hlasování za běhu v doménové vrstvě}, label={lst:excused-count}, tabsize=2]
	
public Vote getVote(int id) throws IOException {
	...
	
	int excusedCount = ... 	
	int loggedOffCount = ...
	
	...
	
	// nastaveni hodnot excusedCount a loggedOffCount
	// vraceni vysledku
}
	
\end{lstlisting}

\subsection {Databázová vrstva}
V databázové vrstvě získávám data z databáze pomocí dotazů. Pro komunikaci s databází je použita knihovna Hibernate, která poskytuje objektově-relační mapování, díky kterému jsme abstrahování od databázových tabulek a místo toho pracujeme s objekty (entitami), které jsou danou knihovnou namapovány na dané tabulky. Příkladem takového objektu je entita pro hlasování, jejíž ukázka je na (\ref{vote-entity}). Pomocí anotace \lstinline|Entity| říkáme, že daný objekt je databázovou entitou. Hibernate nám automaticky vytvoří tabulku s danými atributy v databázi. Anotace \lstinline|@Getter| je z knihovny Lombok a slouží pro vygenerování getterů pro všechny atributy. Anotací \lstinline|@Id| specifikujeme atribut, který má být primárním klíčem v tabulce.

\begin{lstlisting}[caption={Entita Vote reprezentující hlasování}, label={lst:vote-entity}, tabsize=2]

// dalsi anotace
@Entity(name = VOTE)
@Getter
public class Vote {
	
	@Id
	private int id;

 	private LocalDateTime dateTime;

	// zbytek atributu
}

\end{lstlisting}

\noindent Pro dotazování se nad daty používám knihovnu spring-data-jpa, která poskytuje rozhraní \lstinline|JpaRepository|, který obsahuje základní metody pro manipulaci s danou entitou jako např. \lstinline|findAll()| pro získání všech záznamů z tabulky nebo \lstinline|findById()| pro získání záznamu s daným id. Největší sílou této knihovny je však možnost vytvoření vlastních metod, kterým se říká query metody. Dotaz se sestaví na základě pojmenování query metody podle určitých pravidel. Např. následující metoda vrací seznam hlasování ve volebním období, který začal daným volebním rokem:

\begin{lstlisting}[caption={Repozitář pro hlasování}, label={lst:be-repository-vote}, tabsize=2]
// Soubor VoteRepository.java
@Repository
public interface VoteRepository extends JpaRepository<Vote, Integer> {
	
	...
	
	List<Vote> findByElectionYear(int electionYear);
	
}
\end{lstlisting}

\noindent Přitom nebylo potřeba metodu implementovat. Knihovna si na základě názvu metody implementaci vygeneruje. Metodu lze modifikovat, aby vracela stránkovaný obsah:

\begin{lstlisting}[caption={Ukázka query metody pro dotazování se nad stránkovaným obsahem}, label={lst:repository-paging}, tabsize=2]
// Soubor VoteRepository.java
Page<Vote> findByElectionYear(int electionYear, Pageable pageable);
\end{lstlisting}

\noindent Lze i vytvořit komplexnější dotaz, který se dotazuje nad entitou na základě dvou podmínek:

\begin{lstlisting}[caption={Ukázka query metody s dvěma podmínkami}, label={lst:repository-paging}, tabsize=2]
// Soubor MembershipRepository.java
boolean existsByPersonIdAndAgencyId(int personId, int agencyId);
\end{lstlisting}

zdroj: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/


\section{Zpracování dat}
Backend každý den o půl noci aktualizuje databázi podle zdrojových dat na webu PSP. Aktualizace probíhá v následujících krocích:

\begin{itemize}
	\item \textbf{Stažení zdrojových souborů} - Zdrojové soubory jsou ve formátu zip a jsou stažené z webu PSP (https://www.psp.cz/sqw/hp.sqw?k=1300).
	\item \textbf{Extrakce datových souborů} - Ze zdrojových souborů jsou vyextrahovány datové soubory, které jsou ve formátu UNL.
	\item \textbf{Pročištění dat} - Některé datové soubory obsahují duplicitní záznamy. Ty jsou pro snadnější parsování odstraněny.
	\item \textbf{Parsování dat} - Datové soubory jsou zparsovány a načteny do Java objektů.
	\item \textbf{Transformace dat} -  Objekty jsou ztransformovány do požadované podoby.
	\item \textbf{Uložení dat do databáze} - Ztransfomovaná data jsou perzistentně uložena do databáze.
\end{itemize}

\subsection{Stahování zdrojových souborů}
Stahování zdrojových souborů má na starosti třída následující třída:

\begin{lstlisting}[caption={Třída pro stahování zdrojových souborů}, label={lst:psp-downloader}, tabsize=2]
// Soubor PspFilesDownloader.java
public class PspFilesDownloader {
	public static void downloadFiles() throws IOException {
		downloadHlasovani();
		downloadPoslanci();
	}

	// dalsi metody
}
\end{lstlisting}

\noindent Tato třída pro stahování souborů na základě URL interně používá knihovnu \lstinline|commons-io| (\ref{lst:common-io-downloader}). Knihovna poskytuje metodu \lstinline|copyURLToFile|, která akceptuje parametr pro URL zdrojového souboru a parametr pro lokální soubor, do kterého se má zdrojový soubor nakopírovat.

\begin{lstlisting}[caption={Ukázka stahování dat pomocí knihovny \lstinline|commons-io|}, label={lst:common-io-downloader}, tabsize=2]
// Soubor FileDownloader.java
public class FileDownloader {
	
	public static void download(
		String downloadUrlString, 
		String downloadDestination) {
		
		File file = new File(downloadDestination);
		URL downloadUrl = new URL(downloadUrlString);
		
		FileUtils.copyURLToFile(downloadUrl, file);
	
		...
	}
}
\end{lstlisting}

zdroj: https://commons.apache.org/proper/commons-io/

\subsection{Extrakce datových souborů}
Pro extrakci datových souborů byla použita knihovna \lstinline|zip4j|. Ta poskytuje třídu \lstinline|ZipFile| pro vytvoření objektu reprezentujícího lokální soubor ve formátu zip. Konstruktoru této třídy je předána lokace souboru v souborovém systému. Tato třída poskytuje metodu \lstinline|extractFile()| pro extrakci souborů ze zipu. Akceptuje tři parametry:

\begin{itemize}
	\item Název souboru, který se má vyextrahovat.
	\item Adresář, do které se má soubor vyextrahovaný soubor uložit.
	\item Výsledný název ukládaného souboru. V našem případě je stejný jako název před vyextrahováním souboru.
\end{itemize}

\noindent Zde je ukázka kódu pro popsanou extrakci souborů:

\begin{lstlisting}[caption={Ukázka extrakce souborů ze zipu}, label={lst:zip4j}, tabsize=2]
// Soubor ZipExtractor.java
public class ZipExtractor {

	public static void extract(
		String pathToZip, 
		String fileToExtract, 
		String destinationDir
	) {
		ZipFile zipFile = new ZipFile(pathToZip)
		zipFile.extractFile(fileToExtract, destinationDir, fileToExtract);
		
	}
		
}
\end{lstlisting}

zdroj: https://github.com/srikanth-lingala/zip4j

\subsection{Pročištění dat}
Některé datové soubory obsahují duplicitní záznamy. Ty jsou odstraněny pomocí skriptu napsaného v jazyce Bash:

\begin{lstlisting}[caption={Skript pro odstranění duplicitních řádků}, tabsize=2]
// Soubor removeDuplicates.sh.java
for FILE in "$1"/*; do
	sort "$FILE" | uniq > 'tmp.unl'
	mv 'tmp.unl' "$FILE"
	rm 'tmp.unl'
done
\end{lstlisting}

\noindent Skript funguje následovně:

\begin{itemize}
	\item Skript předpokládá ve svém prvním argumentu cestu ke adresáři, kde se nachází datové soubory.
	
	\item Na začátku se iteruje přes všechny soubory v daném adresáři.
	
	\item Každý soubor se pomocí příkazu \lstinline|sort| seřadí vzestupně podle abecedy.
	
	\item Ze seřazeného souboru se odstraní duplicitní řádky jdoucí za sebou pomocí příkazu \lstinline|uniq|. Vy tuto chvíli jsou ze souboru odstraněny všechny duplicity.
	
	\item Zbytek kódu již je pouze přesouvání obsahů souborů tak, aby datové soubory s odstraněnými duplicity měly jejich originální název.
\end{itemize}

\noindent Skript je volán ze souboru \lstinline|PspFilesCleaner|. Důvodem pro odstranění duplicit pomocí jazyka Bash a ne přímo pomocí Javy je to, že v Bashi jsou operace jednodušší a rychlejší než v Javě. 

\subsection{Parsování dat}
Pro parsování zdrojových dat používám knihovnu \lstinline|opencsv|. Ta umožňuje parsovat CSV soubory tak, že každý řádek v souboru namapuje na objekt. Mapování sloupců v souboru na atributy objektu je implementováno přidáním anotací k příslušným atributům. Vysvětlíme si na příkladu. Nejdříve je potřeba vytvořit třídu, do jejíž instancí se napamatují záznamy ve zdrojovém souboru. Ta bude mít u atributů anotaci určující pozici neboli číslo sloupce záznamu. Hodnota tohoto sloupce se pak napamatuje na tento atribut:

\begin{lstlisting}[caption={Parsování datového souboru omluvy.unl}, tabsize=2]
// Soubor Omluva.java
public class Omluva {
	@CsvBindByPosition(position = 0)
	private int idOrgan;
	
	@CsvBindByPosition(position = 1)
	private int idPoslanec;

	// dalsi atributy	
}
\end{lstlisting}

\noindent Nyní lze datový soubor zparsovat a namapovat na tuto třídu. Knihovna poskytuje třídu \lstinline|CsvToBeanBuilder|, které předáme objekt typu |Reader|. Ta slouží pro čtení znaků ze streamu. V tomto případě je do streamu posílány data z datového souboru. Třídá \lstinline|CsvToBeanBuilder| poskytuje metody, kterými specifikujeme:

\begin{itemize}
	\item Třídu, na kterou se mají záznamy namapovat.
	\item Oddělovač hodnot v záznamu.
	\item Určení, kdy je hodnota null. V tomto případě hodnota interpretována jako null, pokud je prázdná.
	\item Ignorování složených závorek.
\end{itemize}

\begin{lstlisting}[caption={Parsování datového souboru omluvy.unl}, tabsize=2]
// Soubor OmluvyParser.java
	
public class OmluvyParser extends UnlParser {
	
	public List<Omluva> read() {
		String filePath = PspPath.Unl.OMLUVY;
		BufferedReader reader = getReader(filePath);
		
		return new CsvToBeanBuilder<Omluva>(reader)
		.withType(Omluva.class)
		.withSeparator(UNL_SEPARATOR)
		.withFieldAsNull(UNL_NULL_SEPARATOR)
		.withIgnoreQuotations(true)
		.build()
		.parse();
		
	}
}
	
\end{lstlisting}

zdroj: https://opencsv.sourceforge.net/

\subsection{Transformace a uložení dat}
Po zpasrování datových souborů a namapování záznamů na objekty lze tyto objekty začít ztransformovat do žádané podoby. Kód pro transformaci má u všech typů dat podobný tvar:

\begin{lstlisting}[caption={Transformace objektu Omluva na databázový objekt Excuse}, tabsize=2]
// Soubor ExcuseLoader.java
	
public class ExcuseLoader extends BaseLoader {

    private final OmluvyParser omluvyReader;
    private final ExcuseRepository excuseRepository;

    public void load() {
			excuseRepository.deleteAllInBatch();
			List<Omluva> omluvaList = omluvyReader.read();
			
			List<Excuse> excuses = omluvaList.parallelStream()
						.map(omluva -> {
							// transformace
						})
					.collect(Collectors.toList());
				
			Lists
				.partition(excuses, BATCH_SIZE)
				.forEach(excuseRepository::saveAll);

	}

}
\end{lstlisting}

\noindent 
Před samotným parsováním jsou smazány všechny záznamy v příslušné tabulce. Poté probíhá parsování datových souborů a seznamu namapovaných objekt. Z tohoto seznamu je vytvořen paralelní stream, což stream, který potenciálně zpracuje objekt v seznamu paralelně. Každý objekt je ztransformován a namapován na databázový objekt. Konkrétní implementace transformace se liší od typu entity. Ztransformovaná data jsou perzistetně uložena do databáze. Ukládání je optimalizováno tak, že se neukládá po jednom ale po skupinách. Každá skupina obsahuje 1000 objektů. Ukládáme tedy po 1000 objektech.

