\chapter{Implementace mobilní aplikace}
\setcounter{page}{1}
\label{ch:implementation}

V rámci této podkapitoly bude popsána implementace mobilní aplikace. V první podkapitole budou popsány použité nástroje a technologie. Mobilní aplikace je implementována pomocí Googlem doporučené architektury pro vývoj mobilních aplikací (\ref{subsec:architecture-google}). Následující sekce budou rozděleny tak, aby odpovídaly jednotlivým vrstvám této architektury.

\section{Použité nástroje a technologie}
V této sekci budou popsány hlavní nástroje a technologie použité pro implementaci mobilní aplikace.

\subsubsection *{Android Studio}
Mobilní aplikace byla vytvořena ve vývojovém prostředí Android Studio, což je oficiální IDE pro vývoj mobilních aplikací pro Android \cite{androidstudio}. Výhody tohoto IDE jsou:

\begin{itemize}
	\item \textbf{Podpora pro Android} - Android Studio je IDE určené pro vývoj mobilních aplikací pro Android. Po spuštění IDE se hned zobrazí průvodce pro instalaci Android SDK obsahující nástroje potřebné pro vývoj aplikací. Po instalaci je SDK připravené k použití. Není tedy potřeba SDK manuálně instalovat z internetu a naimportovat do IDE. IDE Dále poskytuje průvodce pro vytvoření projektu, pomocí kterého lze vybrat jednu z existujích šablon pro různé typy projektů. Po zvolení šablony IDE vytvoří projektový adresář se zdrojovými kódy, závislostmi a konfiguračními soubory pro danou šablonu. Po vytvoření projektu je aplikace prázndá, ale je ve spustitelném stavu.
	
	\item \textbf{Emulátor} - Android Studio poskytuje vestavěný emulátor, který emuluje fyzické mobilní zařízení. Díky tomu může uživatel testovat své aplikace na různých zařízeních s různými konfiguracemi (např. různé rozměry zařízení, verze Androidu).
		
	\item \textbf{Klávesové zkratky} - Jeden z hlavních důvodů pro použití IDE založených od JetBrains jsou klávesové zkratky, které jsou stejné pro všechna IDE od JetBrains. Tyto zkratky zvyšují produktivitu vývojáře.
\end{itemize}

\subsubsection *{Gradle}
Gradle je nástroj pro automatizaci sestavování programu, tj. automatizace kompilace zdrojového kódu do binárního kódu, testování a zabalení do balíčku. Toto jsou další výhody Gradlu: 

\begin{itemize}
	\item \textbf{Gradle Pluginy} - Poskytují Gradlu další nástroje jako např. možnost kompilovat programovací jazyk Kotlin, parsovat anotace nebo generovat kód na základě konfiguračního souboru. 
	
	\item \textbf{Externí knihovny} - Pomocí Gradlu lze do aplikace přidat knihovny, které se stáhnou z předem definovaného vzdáleného repozitáře.
	
	\item \textbf{Konfigurace} - Gradle umožňuje konfigurovat pluginy a aplikaci. U Androidu lze nakonfigurovat např. SDK verzi, verzi Kotlinu, aktivaci Jetpack Compose toolkitu (\ref{ssec:jetpack-compose}).
\end{itemize}

\noindent Alternativou je nástroj Maven, který lze také použít pro vývoj mobilní aplikace pro Android. Oba mají své výhody a nevýhody pro různé situace. Rozhodl jsem se však pro Gradle, jelikož při vytváření projektu v Android Studiu nebyla možnost výběru mezi Gradlem a Mavenem. Projekt byl automaticky nakonfigurován pomocí Gradlu. Předpokládám tedy, že Google preferuje Gradle jako nástroj pro vývoj v Androidích aplikací. Maven by se musel nakonfigurovat manuálně, což by pro zprovoznění aplikace bylo časově náročné, a nejspíš i zbytečné.

\subsection *{Kotlin}
Pro mobilní aplikaci byl použit programovací jayzk Kotlin \cite{kotlin}, který je od roku 2017 preferovaným jazykem pro Android \cite{google-prefers-kotlin}. Původním programovacím jayzkem pro Android byla Java \cite{java}. Kotlin má však oproti němu několik výhod:

\begin{itemize}
    \item \textbf{Je stručný} - Kotlin umožňuje např. vytvořit 
    singleton pomocí klíčového slova \lstinline{object} \cite{kotlin-object}.
    
    \item \textbf{Je bezpečný} - Kotlin rozlišuje null a non-null datové typy. Non-null typy lze dereferencovat vždy, null typy pouze po kontrole výskytu hodnoty null. To je vynuceno typovým systémem Kotlinu. Díky tomu není možné zkompilovat kód, v kterém by se dereferencovala hodnota null, kvůli čemuž by aplikace spadla.
    
    \item \textbf{Je expresivní} - Kotlin byl navržen s důrazem na stručnost a výstižnost kódu.
\end{itemize}

\subsubsection*{Kotlin Coroutines}

\noindent Dalším důvodem pro použití Kotlinu souvisí s dlouze běžícími blokujícími operacemi jako např. síťovými a databázovými operacemi. Android aplikace běží defaultně na hlavním vláknu, které má na starosti vykreslování obrazovky a obsluhu událostí. Pokud je na tomto vlákně provedena dlouze běžící blokující operaci, vlákno se zablokuje na delší dobu a nebude moct obsluhovat události. Uživatelovi se aplikace pak jeví jako zamrznutá. Jedním řešením pro tento problém je vytvořit nové vlákno a provést operaci na něm. Dvě různá vlákna běží paralelně, a tudíž operace běžící na nově vytvořeném vlákně nebude blokovat hlavní vlákno, a tudíž aplikace nezamrzne. Problémem však je, že tvorba vláken a jejich správa jsou drahé operace. 

Alternativním řešením jsou Kotlin Coroutines - paměťově nenáročný způsob, jak psát paralelní kód. Přesné fungování coroutinů je nad rámec této práce, pro účely této práce však stačí vědět, že coroutines se chovají paměťově nenáročná vlákna. To znamená, že lze vytvořit několik coroutinů, z nichž každý reprezentuje nějaký kus paralelně běžícího výpočtu. Oproti vláknům lze coroutinů spustit mnohem více (na běžném počítači klidne v řádu stovek nebo tisíců). Zde je příklad použití coroutiny:

\begin{lstlisting}[caption={Příklad použití coroutiny}, label={lst:coroutine-example}, tabsize=2]
// Soubor ListViewModel.kt
class ListViewModel {

	// zbytek implementace

	init {
		viewModelScope.launch {
			// paralelne bezici operace 1
		}
		
		viewModelScope.launch {
			// paralelne bezici operace 2
		}
	}

	// zbytek implementace
}
\end{lstlisting}

\noindent V tomto kusu kódu je coroutina pro operaci 1 vytvářena zavoláním funkce \lstinline|launch| na objektu \lstinline|viewModelScope|. Funkce akceptuje callback funkci, která bude zavolána v rámci vytvořené couroutiny. To znamená, že callback funkce bude běžet paralelně vzhledem k ostatním  coroutinám, v tomto případě vzhledem ke coroutině spouštějící druhou operaci. Důležité je, že obě coroutiny běží paralelně, ale na stejném vlákně. Dále objekt \lstinline|viewModelScope| určuje scope, v kterém běží coroutina. Ten určuje životní cyklus dané coroutiny. Pokud skončí scope a coroutina ještě nedoběhla, coroutina automaticky ukončí svůj běh. Jednoduchým příkladem scopu je scope samotné aplikace. Pokud je aplikace spuštěna, pak scope existuje a coroutina může běžet. Pokud je aplikace zavřena, scope přestane existovat a coroutina přestane běžet. Díky tomu lze předejít únikům dat. Když by byla aplikace zavřena a scope by stále existoval, pak by coroutina stále běžela, a až by doběhla, mohla by nějakým způsobem modifikovat data nebo data někám přidávat. při opětovném spuštění aplikace však jsou reference na tato data ztracena.

Další důležitou vlastností coroutinů je to, že callback funkce, kterou volá, je suspendovatelná. To znamená několik věcí

\begin{itemize}
	\item Deklare funkce je označená klíčovým slovem \lstinline|suspend|
	\item Suspendovatelná funkce může volat ostatní suspendovatelné funkce. Naopak nesuspendovatelná funkce může volat \textbf{pouze} nesuspendovatelné funkce.
	\item Suspendovatelná funkce může coroutinu suspendovat, tj. pozastavit ji, a uvolnit tím vlákno pro použití jinou coroutinou.
\end{itemize}

\noindent Důležitý je třetí bod. Díky mechanizmu pro suspendování coroutiny mohou coroutiny bežět paralelně. Příklad suspendovatelné funkce, která suspenduje coroutinu, je funkce \lstinline|delay()|, která coroutinu suspenduje na určitý počet milisekund. Během této doby je vlákno uvolněno pro použití jinou coroutinou. Jakmile uběhne daný časový interval, coroutina pokračuje ve svém běhu. Častějším případem použití je např. zavolání síťové operace prostřednictvím knihovny ze třetí strany, která poskytuje suspendovatelné funkce, v rámci kterých je interně implementován suspendovací mechanizmus. Tedy jakmile se provede síťová operace a čeká se na výsledek, knihovna coroutinu sama suspenduje. Uživatel tím pádem nemusí manuálně suspendovat coroutinu po zavolání dlouze běžící operace, ale pouze zavolá funkci knihovny, a ta se postará o zbytek. Tato knihovna bude detailněji popsána v (\ref{sec:impl-network}).

\subsection*{Kotlin Flow}
Kotlin Flow \cite{kotlinflow} je datový typ, který reprezentuje asynchronní proud hodnot, který poskytuje data v čase. Funguje tak, že klientský kód se k proudu zaregistruje, a stane se konzumentem dané flow. Kód produkující nové hodnoty a vkládající je do tohoto proudu je producentem dané flow. Jakmile producent vyprodukuje novou hodnotu a vloží ji do proudu, konzument hodnotu automaticky zkonzumuje, a na základě ní provede nějakou akci. Produkce hodnot nezačíná tehdy, když je vytvořena flow, ale až když se k ní konzument explicitně (pomocí funkce) zaregistruje a začne ji konzumovat. Flow je asynchronní proud hodnot, tj. hodnoty proudu jsou produkovány asynchronním způsobem (např. jsou získávány vzdáleně z backendu). Pro asynchronní produkci dat se používají coroutiny. Flow může být filtrována a transformována, tj. její hodnoty mohou být namapovány na jiné. Různé flow mohou být mezi sebou kombinovány, aby konzument mohl pracovat s hodnotami obou flowů zároveň. Lze nastavit, zda má konzument zareagovat na produkci nových hodnot v obou flowů zároveň nebo jenom jednoho z flowů. Všechny zmíněné operace na flowech lze provést zavoláním funkcí na dané flow a lze je řetězit. Zde je příklad flow, která produkuje seznam hlasování:

\begin{lstlisting}[caption={Příklad použití flow}, label={lst:flow-general}, tabsize=2]
// Soubor VoteListViewModel.kt
class VoteListViewModel: ViewModel() {
	
	// zbytek implementace
	
	private val _currentElectionYear = MutableStateFlow(2021)	
	val currentElectionYear: StateFlow<Int> = _currentElectionYear
	
	private val _searchText = MutableStateFlow("")
	val searchText: StateFlow<String> = _searchText
	
	init {
		viewModelScope.launch {
			currentElectionYear.combine(searchText, ::Pair)
			.collectLatest { pair ->
				// zde jsou konzumovany hodnoty pair
				// zde jsou provadeny dalsi operace nad hodnotou pair
			}
		}
	}

	fun onSearchTextChange(newText: String) {
		_searchText.value = newText
	}

	// zbytek implementace
}
\end{lstlisting}

\noindent Flow produkuje data asynchronně pomocí coroutinů a každá coroutina musí běžet v nějakém scopu, tudíž každá registrace konzumenta k flow musí proběhnout ve scopu. V tomto případě je použit scope \lstinline|viewModelScope|, což je scope jendoho z komponentu Androidu, view modelu, který bude vysvětlen později. V rámci coroutiny jsou kombinovány dvě flowy, \lstinline|currentElectionYear| a \lstinline|searchText|, do jednoho flowu produkující pár hodnot. Toho je dosaženo pomocí funkce \lstinline|combine| s parametrem \lstinline|::Pair|, což je reference na konstruktor třídy \lstinline|Pair|, pomocí kterého se vytváří flow párů. Všimněme si, že datovými typy flowů je \lstinline|StateFlow|. Existence těchto flowů je závislé na životním cyklu Android komponenty, v kterém běží. V tomto případě běží ve view modelu, který ještě existuje v rámci životního cyklu jiné Android komponenty. Pokud jedna z těchto komponent je po konci svého životního cyklu, všechny \lstinline|StateFlow| přestanou produkovat hodnoty a jsou odebrány z paměti. Po zkombinování dvou různých flow do jedné je výsledné flow konzumováno pomocí funkce \lstinline|collectLatest|. V tuto chvíli může začít produkce hodnot. Jak jde však vidět, tak první flow produkuje na začátku pouze jednu hodnotu 2021 a druhá flow pouze prázdný řetězec "". Další produkce dat může proběhnout buď v reakci na nějakou událost (např. kliknutí na tlačítko nebo psaní) nebo na načtení dat ze sítě, databáze, lokálního úložiště atd. Příklad kódu produkující data pro flow je funkce \lstinline|onSearchTextChange|, která do dané flow jednoduše uloží novou hodnotu. V tuto chvíli chceme, aby se zavolala callback funkce uvnitř \lstinline|collectLatest|. Nemusíme ji však zavolat přímo, konzument totiž na změnu hodnoty ve flow zareaguje a spustí daný kód sám. Kotlin Flows mají tedy následující výhody:

\begin{itemize}
	\item Proud hodnot je asynchronní a založený na paměťově nenáročných coroutinech.
	
	\item Proudy lze elegantním způsobem filtrovat a transformovat. Tyto operace lze řetězit.
	
	\item Produkce nové hodnoty v proudu automaticky spustí kód konzumenta tohoto proudu.
	
	\item Kód je čitelnější.
\end{itemize}


\subsubsection *{Android komponenty}
Aplikace v Androidu jsou složeny z Android komponentů, které mají na starosti různé odpovědnosti:

\begin{itemize}
	\item Application - Reprezentuje celou aplikaci. V rámci práce je používaná pouze pro nakonfigurování DI pomocí Hiltu, které bude popsáno v následující sekci.
	\item Activity - Reprezentuje obrazovku. Je to vstupní bod pro vytvoření UI a pro počáteční inicializace.
	\item ViewModel - Reprezentuje komponentu, která definuje business logiku a drží si stav UI elementů. Změna stavu komponenty ViewModel způsobí i změnu UI. ViewModel si pamatuje data i po konfiguračních změnách (např. otočení mobilu).
\end{itemize}

\subsubsection *{Hilt}
Hilt je DI knihovna pro Android. Poskytuje kontejnery pro každou Android komponenty. Tyto kontejnery spravují objekty a jejich závislosti a jsou použity pro injektování závislostí. Příkladem injektování kódu lze vidět na (\ref{lst:hilt}). Do třídy \lstinline|GetAppStateUseCase| injektujeme pomocí anotace \lstinline|@Inject| implementataci rozhraní \lstinline|AppStateRepository|.

\begin{lstlisting}[caption={Příklad použití DI pomocí knihovny Hilt}, label={lst:hilt}, tabsize=2]
class GetAppStateUseCase @Inject constructor(
	val appStateRepository: AppStateRepository,
) {...}

interface AppStateRepository {...}
\end{lstlisting}

\noindent Pro konfiguraci závislostí, na základě kterého Hilt sestaví kontejnery, jsou používány tzv. moduly - objekty pro konfiguraci závislostí. V konfigurace (\ref{lst:hilt-module}) říkáme, že do proměnných typu \lstinline|AppStateRepository| budou injektován objekt \lstinline|AppStateRepositoryImpl|. Objekt je přiom instanciován jako singleton. Objekt zároveň potřebuje závislost na \lstinline|PspRemoteDataSource|, který musí být opět někde nakonfigurován, aby tu mohl být injektován. Buď v tom samém modulu nebo v jiném, pokud chceme moduly pro čitelnost nějakým způsobem rozdělit.

\begin{lstlisting}[caption={Příklad konfigurace závislostí pro Hilt}, label={lst:hilt-module}, tabsize=2]
@Module
@InstallIn(SingletonComponent::class)
object DataModule {
	
	@Provides
	fun provideAppStateRepository(
	pspRemoteDataSource: PspRemoteDataSource
	): AppStateRepository {
		return AppStateRepositoryImpl(pspRemoteDataSource)
	}

}
\end{lstlisting}

\section {Implementace uživatelského rozhraní}
V této sekci bude popsána implementace uživatelského rozhraní.

\subsection*{Jetpack Compose}
\label{ssec:jetpack-compose}
Jetpack Compose je Androidem doporučený způsob pro implementaci uživatelského rozhraní. Rozhraní je implementováno voláním tzv \textit{composable} funkcí, což jsou funkce anotované anotací @composable a reprezentují nějaký UI element na obrazovce. Jetpack Compose nám již poskytuje nativní UI elementy jako text a tlačítko nebo kontejnery pro seskupení element do řádku či sloupců. Tyto nativní UI elementy lze kombinovat, a tím vytvořit složitější komponenty. Tyto složitější komponenty lze pak zapouzdřit do vlastně definované composable funkce. Důsledkem je to, že celé UI popisováno pomocí composable funkcí, které volají další composable funkce. Díky tomu je kód pro vytvoření UI modulární. 

Jelikož composable funkce jsou vlastně jenom funkce napsané v programovacím jazyce, lze jim předávat parametry, které určují vzhled či chování daného UI elementu. Které parametry composable funkce přijímá a co určuji závisí na implementaci dané funkce. Jsou parametry, které mění např. barvu a velikost daného elementu. Dále jsou parametry, kterým předáváme funkci. Tato funkce může být volána např. když je na daný element kliknuto. Také jsou parametry, které určují textový obsah nějakého textového elementu. Výhodou použití knihovny Jetpack Compose je možnost definovat UI pomocí programovacího jazyka. To znamená, že lze využít cykly (např. pro vytvoření seznamu elementů) nebo podmínky (např. pro podmíněné vykreslování). Implementace rozhraní je díky tomu jednoduchá a intuitivní.

Alternativou k Jetpack Composu jsou XML layouty, které k popisu UI používají externí XML soubor, kde je rozhraní popisováno pomoxí XML tagů a jejich atributů. Hlavní myšlenkou tohoto přístupu je to, že oddělujeme popis uživatelského rozhraní od programového kódu, díky čemuž je kód čitelnější a udržitelnější. Míchání popisu UI a programového kódu se však nikdy nevyhneme, jelikož layoutům se musí minimálně předat aspoň data. Toho lze dosáhnout pouze propojením programového kódu s layoutem. Pokud implementujeme dynamický seznam, situace pro XML layouty je ještě horší, neboť implementace vyžaduje hodně boilerplate kódu. Pro Jetpack Composu je vytvoření takového seznamu otázkou pár řádků kódu.

Z výše uvedených důvodů jsem se rozhodl uživatelské rozhraní implementovat pomocí Jetack Compose.

\vspace*{10px}
\noindent zdroj: https://developer.android.com/develop/ui/views/layout/recyclerview
\noindent zdroj: https://developer.android.com/jetpack/compose/lists
zdroj: https://developer.android.com/jetpack/compose

\vspace*{10px}

\subsubsection*{Composable funkce}
Základním stavebním kamenem pro tvorbu uživatelského rozhraní pomocí knihovny Jetpack Compose jsou composable funkce. V (\ref{lst:jc-text}) lze vidět použití nativní composable funkce \lstinline|Text|, která slouží pro vytvoření textového UI elementu. Vidíme, že funkce přijímá parametr \lstinline|text|, který určuje textový obsah.

\begin{lstlisting}[caption={Příklad použití composable funkce Text.}, label={lst:jc-text}]
Text(text = "Vysledky hlasovani")
\end{lstlisting}

\noindent Composable funkce lze kombinovat pro vytvoření složitějších composable funkcí (\ref{lst:jc-combine}). Vytváříme zde ikonku pomocí funkce \lstinline|Icon| a text. Ikonka přijímá parametr specifikující objekt reprezentující danou ikonku a text používaný pro přístupové služby. Oba elementy jsou pak seskupeny do řádku pomocí kontejnerové composable funkce \lstinline|Row|.

\begin{lstlisting}[caption={Příklad skládání composable funkcí. Vykreslí ikonku a text vedle sebe.}, label={lst:jc-combine}, tabsize=2]
Row {
	Icon(
		imageVector = Icons.Filled.ArrowBack,
		contentDescription = "Tlacitko zpet",
	)
	Text(text = "Detail hlasovani)
}
\end{lstlisting}

\noindent Pomocí parametrů lze měnit i vzhled a chování composable funkce. (\ref{lst:jc-parameters}). Vytváříme zde tlačítko  s textem a černým okrajem, které při kliknutí vypíše do konzole text.

\begin{lstlisting}[caption={Příklad parametrů pro změnu vzhledu a chování.}, label={lst:jc-parameters}, tabsize=2]
Button(
	onClick = { println("Kod pro ulozeni") },
	border = BorderStroke(0.dp, Color.Black)
) {
	Text(text = "Ulozit")
}
\end{lstlisting}

\vspace*{10px}

\subsubsection*{Kompozice a rekompozice}
Kompozice funkce je proces, kdy se zavolá. Rekompozice funkce je pak proces, kdy se zavolá znovu v reakci na změnu jejího lokálního stavu nebo stavu ve ViewModelu, na kterém je závislý, nebo na rekompzici rodiče. Lokální stav composable funkce je popsána v následující sekci. Důsledkem je to, že změna composable funkce (jejího stavu) spustí rekompozici pouze této funkce a všech funkcí, které volá. Ostatní funkce zůstanou nedotčené. Díky tomu dojde k rekompozici pouze u funkcí, kde se něco změnilo nebo potěnciálně změnilo.

\vspace*{10px}

\subsubsection*{Stav composable funkce}
Composable funkce mohou v sobě držet lokální stav. Kód (\ref{lst:jc-state}) ukazuje příklad jeho použití. Zde vidíme text a tlačítko. Text se vykresluje podmíněně podle aktuální hodnoty proměnné \lstinline|expanded|. Defaultní hodnota proměnné \lstinline|expanded| je \lstinline|false|, a tudíž při první kompozici funkce se text nevykreslí. Tlačítko v reakci na kliknutí této proměnné nastaví opačnou hodnotu, což spustí rekompozici funkce. Aby změna této proměnné spustila rekompozici, musí být typu \lstinline|State|. Aby se proměnná však vůbec dala měnit, musí být typu \lstinline|MutableState|, a proto je defaultní hodnota \lstinline|false| obalena do funkce \lstinline|mutableStateOf|. Aby se při rekompozici nenastavila opět defaultní hodnota \lstinline|false|, ale nová hodnota, musí si composable funkce tento stav pamatovat napříř rekompozicemi, a toho dosáhneme pomocí funkce \lstinline|remember|. Klíčové slovo \lstinline|by| je syntactic sugar, který deleguje vrácení hodnoty na funkci \lstinline|remember|. Pro nás to znamená jenom to, že typ proměnné \lstinline|expanded| je Boolean a ne State<Boolean>. Pracuje se s tím pak lépe. 

\begin{lstlisting}[caption={Příklad composable funkce používající lokální stav.}, label={lst:jc-state}, tabsize=2]
	@Composable
	private fun MyExpandableContent() {
		var expanded by remember {mutableStateOf(false)}
		
		Row {
			if (expanded) {
				Text(text = "Zbytek obsahu")
			}
			Button(onClick = { expanded = !expanded },
			) {
				Text(text = "Klikni pro zobrazeni zbytku obsahu")
			}
		}
	}
\end{lstlisting}

\noindent Mnohem obvyklejší je však stav zapouzdřit do ViewModelu, který je určený k ukládání stavu UI, jak je ukázáno na (\ref{lst:jc-viewmodel}). ViewModel si pamatuje stav i při navigaci na jinou obrazovku a zpět. Díky může data stažená např. z internetu přepoužít a nemusí je zbytečně stahovat vícekrát, pokud se data málo mění.

\begin{lstlisting}[caption={Příklad composable funkce používající stav z ViewModelu.}, label={lst:jc-viewmodel}, tabsize=2]
@Composable
private fun MyExpandableContent(viewModel: MyViewModel) {
    val expanded = viewModel.expandeed

		Row {
			if (expanded) {
				Text(text = "Zbytek obsahu")
			}
			Button(onClick = { viewModel.toggleExpanded() },
			) {
				Text(text = "Klikni pro zobrazeni zbytku obsahu")
			}
		}
}

class MyViewModel : ViewModel() {
	val expanded = mutableStateOf(false)
	
	fun toggleExpanded() {
		expanded = !expanded
	}
}
\end{lstlisting}

\noindent zdroj:
https://developer.android.com/jetpack/compose/mental-model

\subsubsection*{Activity}
Aktivita je jedna z hlavních komponent aplikace a reprezentuje obrazovku, do které vkládáme naše uživatelské rozhraní. V rámci aplikace je použita především jako vstupní bod pro vytvoření UI a pro počáteční inicializace stavu aplikace. Aktivita se může nacházet v různých stavech podle toho, zda ji má uživatel v popředí nebo pozadí, nebo zda ji vypíná. Nás bude zajímat především stav, kdy je aktivita poprvé vytvořena, tedy když je aplikace spuštěna. Pro detekci tohoto stavu poskytuje aktivita funkci \lstinline|onCreate|, která se zavolá, když je aktivita vytvořena. V této funkci lze pak provádět žádané operace (\ref{lst:main-activity}). Funkce \lstinline|setcontent| vezme composable funkci \lstinline|PspApp|, zakomponuje ji do aktuální aktivity a nastaví ji jako kořenovou composable funkci.

\begin{lstlisting}[caption={Třída MainActivity. (Soubor \lstinline|psp_fe/app/MainActivity|}), label={lst:main-activity}, tabsize=2]
class MainActivity : ComponentActivity() {

	...
	
	override fun onCreate(savedInstanceState: Bundle?) {
		super.onCreate(savedInstanceState)
		
		...
		
		setContent {
			PspApp()
		}
	}

	...
\end{lstlisting}

\subsection {Implementace prezentační vrstvy}
\label{sssec:impl-ui}
Popis implementace prezentační vrstvy je rozděleno na popis implementace uživatelského rozhraní a popis implementace držitelů stavů a logiky. Nejdřív bude popsána první implementace a po ní druhá. 

Uživatelské rozhraní bylo implementováno pomocí knihovny Jetpack Compose. Pro implementaci byly použity následující composable funkce:

\begin{itemize}
	\item Column - Sloupcový kontejner pro elementy. Hodí se pro pozicování UI elementů na obrazovce. Nehodí se pro dlouhé seznamy elementů ve sloupci, jelikož nedělá rekompozici pouze viditelných elementů, ale všech. Nejde jím scrollovat. Používám ji ve všech místech, kde je potřeba napozicovat UI elementy pod sebou.
	\item LazyColumn - Sloupcový kontejner pro element zoptimalizovaný pro dlouhé seznamy. Dělá rekompozici pouze pro viditelné elementy. Lze jím scrollovat. Používám ji pro zobrazení seznamů, tedy na obrazovce pro seznam hlasování, seznam poslanců, seznam hlasování jednotlivých klubů a seznam hlasování poslance.
	\item Row - Řádkový kontejner pro elementy.
	\item Text - Textový element.
	\item Image - Obrázkový element. Obrázek lze získat pomocí URL adresy. Používám ho pro zobrazení profilové fotky poslance a logů klubů.
	\item Icon - Funkce pro různé ikonky, např. pro ikonky v hlavičce nebo v dolní liště.
	\item IconButton - Tlačítko, který má místo textu ikonky. Používám ji hlavičce pro vytvoření ikonky pro vyhledávání v seznamu hlasování nebo poslanců.
	\item OutlinedButton - Tlačítko s kontrastem barev mezi pozadím a obvodem.
	\item OutlinedTextField - Textové pole s kontrastem barev mezi pozadím a obvodem.
	\item FloatingActionButton - Plovoucí tlačítko. Používám ji pro skok na začátek seznamu.
	\item Scaffold - Kontejner umožňující jednoduchým způsobem sdílet UI element mezi více obrazovkami. Umožňuje také jednoduchým způsobem přidat plovoucí tlačítko.
	\item TopAppBar - Horní lišta.
	\item Spacer - Vytváří mezeru mezi dvěma UI elementy. zda je mezera horizontální nebo veritkální, specifikujeme skrz parametr.
	\item Divider - Oddělovač. Dá se nastavit na vertikální nebo horizontální.
	\item CompositionLocalProvider - Umožňuje přepsat hodnotu kontextu. Používám ji pro lokální přepsání globálních barev.
	\item Box - Kontejner umožňující skládat UI elementy na sebe. Používám ho pro vytvoření popupu s nastavením volebního období v nastavení. Na pozadí je seznam nastavení a na něm se objeví daný popup.
	\item SettingsMenuLink - Composable funkce z knihovny Alorma pro snadné vytvoření prvku v seznamu nastavení přesně podle návrhu. Knihovna ji definuje defaultní vzhled.
	\item ListItemPicker - Composable funkce z knihovny Alorma reprezentující seznam hodnot, kterým lze scrollovat. Knihovna ji definuje defaultní vzhled.
	\item Card - Karta obsahující libovolný obsah a prvek pro akci. Používám ji např. pro elementy v seznam hlasování.
	\item TabRow - Lišta s taby. Používám ji na obrazovce s detailem hlasování a na obrazovce s detailem poslance.
	\item Tab - Reprezentuje konkrétní obrazovku v rámci tabu.
	\item HorizontalPager - Layout umožňující horizontálne scrollovat obsahem. Používám ho pro scrollování mezi taby.
\end{itemize}

\vspace{10px}

\noindent Stav UI a logika pro obsluhu změn UI jsou zapouzdřeny v držitelích stavů a logiky, což jsou view modely. Jsou to objekty, s kterými komunikuje Jetpack Compose pro získání dat nebo pro informování o nějaké události. Na (\ref{lst:view-model}) lze vidět ukázku využití view modelu. Na začátku view modelu se nachází stav pro seznam hlasování. \lstinline|PagingData| je datový typ pro stránkovaný obsah. \lstinline|MutableStateFlow| je datový typ pro flow, který lze měnit. Flow je vyžadován pro implementaci stránkování pomocí \lstinline|PagingData|. Vně view je viditelná pouze imutabilní verze stavu \lstinline|StateFlow|. Pro bezpečnost se se stavem dá manipulovat pouze uvnitř view modelu. Při spuštění view modelu se proveden coroutinová operace v rámci scopu view modelu. To znamená, že pokud je view model odstraněn, zruší se i coroutinová operace. Coroutina získává data pomocí funkce \lstinline|getVotes|. Ta vyžaduje volební rok a klíčová slova pro filtrování seznamu. Jakmile se změní jedna z těchto dvou hodnot, měly by se stáhnout nová data. Obě hodnoty jsou implementeovány jako flow, a proto je nejdřív kombinujeme a zavoláme na nich terminální operátor \lstinline|collectLatest|. Emitované hodnoty se pomocí \lstinline|cachedIn(viewModelScope)|zakešují v rámci view modelu. To znamená, že pokud se na daném flow opět zavolá terminální operátor v jiné části kódu, vrátí se zakešovaná hodnota. 

\begin{lstlisting}[caption={Ukázka využití view modelu}, label={lst:view-model}, tabsize=2]
// Soubor VoteListViewModel.kt
class VoteListViewModel(
...
): ListViewModel(...) {
	
	private val _votes: MutableStateFlow<PagingData<Vote>> =
	MutableStateFlow(PagingData.empty())
	val votes: StateFlow<PagingData<Vote>> = _votes
	
	init {
		viewModelScope.launch {
			currentElectionYear.combine(searchText, ::Pair)
			.collectLatest { pair ->
				getVotes(pair.first, pair.second)
				.cachedIn(viewModelScope)
				.collect { votes ->
					_votes.value = votes
				}
				
			}
		}
	}
	
}
\end{lstlisting}

\vspace{10px}

\noindent Navigace mezi obrazovkami je implementována pomocí composable funkce \lstinline|NavHost|, která definuje jednotlivé destinace. Destinace reprezentuje obrazovku, ke které lze pomocí této funkce navigovat. Destinace je reprezentována řetězcem. Např. destinace pro seznam hlasování se nazývá "votes". Pro samotnou navigaci se používá objekt \lstinline|NavHostController|, na které zavoláme metodu \lstinline|navigate| a předáme ji název destinace, ke které chceme navigovat. Pro navigaci k detailu hlasování nebo poslance používá sepcifičtější název destinace, např. "votes/1234" nebo "member/5678".

\subsection {Implementace doménové vrstvy}
Ukázka implementace doménové vrstvy pro seznam hlasování (\ref{lst:use-case-vote}). Objekt \lstinline|Pager| je vstupním bodem pro stránkovací mechanizmus. Nastavujeme mu defaultní velikost stránky, v době psaní práce je to 20. Dále mu předáme \lstinline|VotesPagingSource| reprezentující zdroj stránkovaných dat. Pager poskytuje proměnnou flow, která bude emitovat stránky. \lstinline|flowOn| nastaví, aby sbírání flow probíhalo na speciálním vlákně IO, aby neprobíhalo na hlavním vlákně. Není to nutné díky používání coroutinů, ale je to dobrá praxe to používat pro síťové operace.

\begin{lstlisting}[caption={Ukázka využití use caseu pro získání seznamu hlasování}, label={lst:use-case-vote}, tabsize=2]
// Soubor GetVotesUseCase.kt
class GetVotesUseCase @Inject constructor(...) {
	
	operator fun invoke(electionYear: Int, searchText: String) = Pager(
		PagingConfig(pageSize = DEFAULT_PAGE_SIZE)
	) {
		VotesPagingSource(
			voteRepository = voteRepository,
			electionYear = electionYear,
			searchText = searchText
		)
	}
	.flow
	.flowOn(Dispatchers.IO)
	
}
\end{lstlisting}

\noindent Doménové vrstvy pro obrazovky, které nepoužívají seznam, jsou přímočařejší. Ukázku takového use caseu lze vidět na (\ref{lst:use-case-vote-detail}).

\begin{lstlisting}[caption={Ukázka využití use caseu pro získání detailu hlasování}, label={lst:use-case-vote-detail}, tabsize=2]
// Soubor GetVoteDetailUseCase.kt
class GetVoteDetailUseCase @Inject constructor(...) {
	
	operator fun invoke(id: Int): Flow<VoteDetails> =
		voteRepository.getVoteDetail(id)
		.flowOn(Dispatchers.IO)	
}
\end{lstlisting}

\subsection {Implementace datové vrstvy}
Datová vrstva slouží pro abstrahování doménové vrstvy od konkrétních datových zdrojů. V aplikaci je použit jediný datový zdroj, a to vzdálený pro získání data z backendu. V datové vrstvě jsou získávána data z datového zdroje v podobě síťových entit. Ty jsou následně namapována na doménové entity pro použití doménovou vrstvou. Ukázka použití je na (\ref{lst:use-case-repository}).

\begin{lstlisting}[caption={Ukázka datové vrstvy pro data o hlasováních}, label={lst:use-case-repository}, tabsize=2]
class VoteRepositoryImpl @Inject constructor(...) : VoteRepository {
	
	override suspend fun getVotes(
		page: Int,
		size: Int,
		electionYear: Int,
		searchText: String
	): List<Vote> =
	pspRemoteDataSource.getVotes(
		page = page,
		size = size,
		electionYear = electionYear,
		searchText = searchText
	).map { it.toDomain() }
	
	...
}
\end{lstlisting}

\vspace{10px}
\noindent Datové zdroje jsou pouze abstrakcí nad konkrétním rozhraním pro získání daného zdroje. Vzdálený datový zdroj tedy abstrahuje datovou vrstvu od přímé komunikace s knihovnou pro získání dat z internetu. Na (\ref{lst:data-source}) je ukázka datového zdroje. Funkce \lstinline|getAppState()| pouze zavolá funkci definovanou pomocí knihovny Retrofit, která bude popsána v následující sekci.

\begin{lstlisting}[caption={Ukázka datového zdroje}, label={lst:data-source}, tabsize=2]
class PspRemoteDataSourceImpl @Inject constructor(
	private val pspApi: PspApi
) : PspRemoteDataSource {
	
	override suspend fun getAppState() = 
		pspApi.getAppState()
		
	...
}
\end{lstlisting}

\subsection{Implementace síťové vrstvy}
\label{sec:impl-network}

\noindent Síťová vrstva je implementována pomocí knihovny Retrofit. Je to HTTP klient pro komunikaci se zdroji na internetu. Aplikaci ho používá pro získání veškerých dat z backendu. Na (\ref{lst:retrofit-votes}) je ukázka použití. URL adresu daného zdroje specifikujeme pomocí anotace \lstinline|@GET|. Pomocí anotací \lstinline|Query| specifikujeme query parametry pro jako číslo stránky a počet stránek. Návratovou hodnotou je seznam API entit. Implementaci této funkce má na starosti knihovna. Data z backendu jsou ve formátu JSON a jsou namapována na objekt v návratovém typu.

\begin{lstlisting}[caption={Ukázka použití knihovny Retrofit pro získání seznamu hlasování z backendu}, label={lst:retrofit-votes}, tabsize=2]
interface PspApi {
	
	@GET("/api/vote")
	suspend fun getVotes(
		@Query("page") page: Int,
		@Query("size") size: Int = DEFAULT_PAGE_SIZE,
		@Query("sortBy") sortBy: String = DEFAULT_VOTE_SORT_BY,
		@Query("order") order: String = DEFAULT_ORDER,
		@Query("electionYear") electionYear: Int
	): List<VoteApiEntity>
	
}
\end{lstlisting}

zdroj: https://square.github.io/retrofit/

\section{Backend}

\subsection {Použité nástroje a technologie}
\subsubsection*{Intellij IDEA}
Backend byl vyvíjen ve vývojovém prostředí Intellij IDEA. Hlavní důvody pro výběr tohoto IDE:

\begin{itemize}
	\item Vestavěný inicializátor Spring Boot aplikací - Pomocí tohoto inicializátor lze nakonfigurovat a nastavit potřebné závislosti ve Spring Boot\footnote{Technologie Spring Boot bude popsána později.} aplikaci jednoduše naklikáním v průvodci.
	
	\item Klávesové zkratky - Toto IDE je vyvíjeno společností JetBrains, a tudíž obsahuje stejné klávesové zkratky jako Android Studio.
\end{itemize}

zdroj: https://www.jetbrains.com/idea/

\subsubsection*{Maven}
Maven je stejně jako Gradle nástroj pro automatizaci sestavování programu. Původně byl použit Gradle kvůli čitelnější syntaxi. Maven byl zvolen z historických důvodů. Původně bylo v plánu backend nasadit na Cloud Azure. Ten poskytoval plugin pro maven, který umožňoval backend nasadit a zprovoznit pomocí jednoho příkazu. Kvůli omezeného free tieru však byl backend nakonec nasazen na jiný cloud (více v kapitole o nasazení). Maven je tedy pozůstatek historického rozhodnutí. Na funkčnosti aplikace to však nemá žádný vliv, a proto se už nepřešlo z Mavenu na Gradle. 

zdroj: https://maven.apache.org/

https://azure.microsoft.com/en-us

\subsubsection*{Spring Boot}
Před popisem technologie Spring Boot si popíšeme technologii Spring, na které je Spring Boot založen. Spring je open-source framework pro vývoj enterprise aplikací. Je to seskupení různých nástrojů pro řešení různých problémů. Pro účely této práce byly využity nástroje pro vytvoření webových aplikacím, ale umožňují implementovat i backend s REST API. Hlavními benefity Springu je množství použitelných nástrojů a dependency injection pomocí anotací.

Spring Boot je framework, který je postavený na Springu a který má za cíl redukci boilerplate kódu a nutnost konfigurace, a tím urychlit vývoj aplikace. Toho dosahuje pomocí autokonfigurace, což je vlastnost Spring Bootu, kdy jsou jednotlivé komponenty (např. rozhraní pro komunikaci s databází, webový server, ORM) automaticky nakonfigurovány Spring Bootem pomocí defaultních hodnot. Defaultní hodnoty jsou Spring Bootem nastaveny na nejčastější hodnoty, aby se tím pokrylo co nejvíce situací, na které může vývojář narazit. Důsledkem je to, že pro zprovoznění komponent je potřeba pouze nainstalovat jejich závislost. Pokud bude potřeba použít jinou konfiguraci (např. pro připojení k databázi chceme použít jiný než defaultní port), Spring Boot to umožňuje. Pointa je však, že knihovnu pouze stáhneme bez nutnosti konfigurace nebo s minimální konfigurací a aplikace lze hned spustit.

Alternativou ke knihovně Spring Boot je knihovna Ktor, pomcí které lze taktéž vytvořit backend s REST API. Výhodou této knihovny je, že je určená pro psaní v Kotlinu. Lze tedy využít všechny výhody tohoto jazyka. Nevýhodou je, že nepodporuje defaultně dependency injection. Pro něj se musí zvlášť stáhnout knihovna a a tu nakonfigurovat. Další nevýhodou oproti Spring Bootu je chybějící autokonfigurace. Vše se tedy musí manuálně nakonfigurovat.

zdroj:

https://spring.io/

https://spring.io/why-spring

https://spring.io/web-applications

https://ktor.io/

\subsubsection*{Java}
Java byla od začátku hlavním programovacím jazykem pro vývoj aplikací pomocí technologie Spring Boot. Od roku 2017 přišla integrace jazyka Kotlin do Spring Bootu a v dokumentaci jsou ukázkové kódy psány jak v Javě tak i Kotlinu. Java má oproti Kotlin větší podporu v komunitě, co se týče vývoji ve Spring Bootu. Když jsem při psaní v Javě narazil na nějaký problém, mnohem šlo najít na internetu řešení než při psaní v Kotlinu. Jedním řešením je hledat řešení v Javě a javovský kód pomocí automatického nástroje ztransfomovat do Kotlinu, výsledný kód bylo však potřeba vždy prošistit, jelikož u všech proměnných vždy obsahoval datové typy, které lze v Kotlinu v některých případech vynechat. Zároveň výstupní kód někdy nebyl kvůli nějaké drobnosti kompilovatelný. Z toho důvodu jsem se rozhodl pro použití Java. Zdá se však, že podpora pro psaní aplikací Spring Boot pomocí Kotlinu je čím dál tím větší. Když bych měl možnost backend přepsat, znovu bych zauvažoval o použití Kotlinu, jelikož je to velmi dobrý programovací jazyk.

zdroj:
 https://spring.io/guides/tutorials/spring-boot-kotlin/

https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0

zdroj:

https://docs.spring.io/spring-boot/docs/current/reference/html/index.html\textbf{}

\subsubsection*{MySQL}
Na databázi backendu nebyly kladeny velké nároky. Pouze bylo potřeba data perzistentní uložit, aby byly připravené pro použití mobilní aplikací. Zvolil jsem tedy MySQL, s kterým jsem měl zkušenosti. Bylo by však možné použít např. i PostreSQL. Na funkčnosti backendu by to však nemělo vliv.

\subsection {Prezentační vrstva}
V prezentační vrstvě byly implementovány jednotlivé endpointy REST API, které přijímají dotazy od mobilní aplikace a vrací ji předzpracovaná data uložena v databázi. Ukázku implementace endpointu pro získání detailu konkrétního hlasování lze vidět na (\ref{lst:controller-votes}). Endpoint pro HTTP GET požadavky je ve Spring Bootu implementován tak, že vytvoříme metodu s libovolným názvem a označíme ji anotací \lstinline|@GetMapping|. V parametru této anotace pak specifikujeme URL adresu daného endpointu. Celá metoda se musí nacházet ve tříde s anotací \lstinline|@RestController|. Endpointy jsou rozděleny do několika tříd podle typu dat (jedna třída pro entity hlasování, druhá pro entity poslance a třetí pro entity klubů). Pokud URL adresa obsahuje parametr identifikující daný zdroj, musí být obsažen v parametru metody a oanotován pomocí \lstinline|@PathVariable|

\begin{lstlisting}[caption={Ukázka kódu pro vytvoření endpointu}, label={lst:controller-votes}, tabsize=2]
// Soubor VoteController.java
@RestController
public class VoteController {
	
	private final VoteService service;
	private final VoteMapper mapper;
	
	...
	
 	@GetMapping("/vote/{id}")
	public DetailedVote getVote(@PathVariable Integer id) {
		Vote vote = service.getVote(id);
		return mapper.toDetailedVote(vote);
	}

\end{lstlisting}

\noindent Query parametry jsou implementovány pomocí anotace \lstinline|RequestParam|, kterému je v parametru předán název parametru: 

\begin{lstlisting}[caption={Ukázka endpointu s request parametrem}, label={lst:request-param}, tabsize=2]
// Soubor VoteController.java
@RestController
public class VoteController {
	
	private final VoteService service;
	private final VoteMapper mapper;
	
	...
	
	@GetMapping("/vote")
	public ResponseEntity<List<GeneralVote>> getVotes(
		@RequestParam(name = "description") String description
		...
	) {
		...
	}
}
\end{lstlisting}

\noindent Podobným způsobem jsou implementovány query parametry pro stránkování (číslo a velikost stránky). Kromě povinného parametru pro název query parametru lze specifikovat i parametr \lstinline|required| pro nastavení volitelnosti nebo  \lstinline|defaultValue| pro nastavení defaultní hodnoty query parametru.

\vspace{10px}
\noindent Na dvou předchozích ukázkách lze vidět použití hodnot \lstinline|service| a \lstinline|mapper|. První reprezentuje doménovou vrstvu, která získá data z databázové vrstvy a druhá obsahuje metody pro mapování objektů, pokud je to potřeba (pokud je struktura entit uložených v databázi jiná než struktura entit pro REST API). Takto jsou implementovány všechny controllery. Controllery, které obsahují endpoint, který vrací seznam, navíc sestavují hlavičky pro HTTP odpověď. K tomu je použita třída \lstinline|HttpHeaders|, kterou poskytuje Spring framework. Instanci této třídy se jednoduchým způsobem nastaví potřebné hodnoty a objekt je controllorem vracen:

\begin{lstlisting}[caption={Ukázka nastavení hlaviček pro stránkování}, label={lst:headers-paging}, tabsize=2]
// Soubor PaginationHeaderGenerator.java
public static HttpHeaders buildHeaders(...) {
	HttpHeaders responseHeaders = new HttpHeaders();

	...
	
	responseHeaders.set(previousPageString, String.valueOf(prevPage));
	responseHeaders.set(nextPageString, String.valueOf(nextPage));
	responseHeaders.set(lastPageString, String.valueOf(lastPage));
	
	return responseHeaders;
}

// Soubor VoteController.java
@GetMapping("/vote")
public ResponseEntity<List<GeneralVote>> getVotes(...) {

	...
	
	HttpHeaders headers = GenericAndPaginationHeaderGenerator
		.buildHeaders(pagedResult.getTotalPages(), page);
	
	...	
	
	return ResponseEntity
		.ok()
		.headers(headers)
		.body(generalVotes);
}
\end{lstlisting}

\subsection {Doménová vrstva}
Doménová vrstva má na starosti business logiku aplikace a abstrahování prezentační vrstvy od implementačních detailů databázové vrstvy. V našem případě backend neobsahuje business logoiku, pouze filtruje data. Ukázka kódu pro získání detailu poslance:

\begin{lstlisting}[caption={Ukázka kódu pro získání detailu poslance}, label={lst:headers-paging}, tabsize=2]

// Soubor MemberService.java
public Member getMember(int id) {
	return memberRepository
	.findById(id)
	.orElseThrow(() -> new MemberNotFoundException(id));
}
	
\end{lstlisting}

\noindent Pro získání seznamů je použito stránkování, které je implementováno pomocí třídy \lstinline|Pageable|. Ta se předá repozitáři, který bude popsán v následující sekci:

\begin{lstlisting}[caption={Ukázka doménové vrstvy pro vrácení seznamu poslanců}, label={lst:headers-paging}, tabsize=2]

// Soubor MemberService.java
public Page<Member> getMembers(PagingParams pagingParams) {
	
	Pageable pageable = PageableGenerator.buildPageable(pagingParams);
	
	if (filterName == null) {
		return memberRepository
			.findByElectionYear(electionYear, pageable);
	} else {
		// kod pro filtrovani poslancu
	}
}
\end{lstlisting}

\noindent Instance třídy \lstinline|Pageable| je vytvořena následovně:

\begin{lstlisting}[caption={Ukázka kódu pro sestavení objektu pro stránkování}, label={lst:paging-object}, tabsize=2]
	
public static Pageable buildPageable(...) {
	Pageable pageable;
	
	...
	
	pageable = PageRequest.of(page, size, sort);
	// napr. page = 2, size = 20, sort = Sort.by("dateTime").descending())
	
	return pageable;
}

\end{lstlisting}

\noindent Doménová vrstva pro ostatní entity jsou implementovány obdobně jako bylo popsáno výše. Výjimkou je metoda pro získání detailu hlasování. Jedním z atributů hlasování jsou statistky hlasování. Výpočet počtu omluvených a nepřihlášených poslanců příliš zpomalovalo zpracování zdrojových dat přes uložením do databáze. Z toho důvodu je tento výpočet prováděn až za běhu, kdy se mobilní aplikace nad daným detailem hlasování dotazuje:

\begin{lstlisting}[caption={Ukázka dopočtu statistik pro detail hlasování za běhu v doménové vrstvě}, label={lst:excused-count}, tabsize=2]
	
public Vote getVote(int id) throws IOException {
	...
	
	int excusedCount = ... 	
	int loggedOffCount = ...
	
	...
	
	// nastaveni hodnot excusedCount a loggedOffCount
	// vraceni vysledku
}
	
\end{lstlisting}

\subsection {Databázová vrstva}
V databázové vrstvě získávám data z databáze pomocí dotazů. Pro komunikaci s databází je použita knihovna Hibernate, která poskytuje objektově-relační mapování, díky kterému jsme abstrahování od databázových tabulek a místo toho pracujeme s objekty (entitami), které jsou danou knihovnou namapovány na dané tabulky. Příkladem takového objektu je entita pro hlasování, jejíž ukázka je na (\ref{vote-entity}). Pomocí anotace \lstinline|Entity| říkáme, že daný objekt je databázovou entitou. Hibernate nám automaticky vytvoří tabulku s danými atributy v databázi. Anotace \lstinline|@Getter| je z knihovny Lombok a slouží pro vygenerování getterů pro všechny atributy. Anotací \lstinline|@Id| specifikujeme atribut, který má být primárním klíčem v tabulce.

\begin{lstlisting}[caption={Entita Vote reprezentující hlasování}, label={lst:vote-entity}, tabsize=2]

// dalsi anotace
@Entity(name = VOTE)
@Getter
public class Vote {
	
	@Id
	private int id;

 	private LocalDateTime dateTime;

	// zbytek atributu
}

\end{lstlisting}

\noindent Pro dotazování se nad daty používám knihovnu spring-data-jpa, která poskytuje rozhraní \lstinline|JpaRepository|, který obsahuje základní metody pro manipulaci s danou entitou jako např. \lstinline|findAll()| pro získání všech záznamů z tabulky nebo \lstinline|findById()| pro získání záznamu s daným id. Největší sílou této knihovny je však možnost vytvoření vlastních metod, kterým se říká query metody. Dotaz se sestaví na základě pojmenování query metody podle určitých pravidel. Např. následující metoda vrací seznam hlasování ve volebním období, který začal daným volebním rokem:

\begin{lstlisting}[caption={Repozitář pro hlasování}, label={lst:be-repository-vote}, tabsize=2]
// Soubor VoteRepository.java
@Repository
public interface VoteRepository extends JpaRepository<Vote, Integer> {
	
	...
	
	List<Vote> findByElectionYear(int electionYear);
	
}
\end{lstlisting}

\noindent Přitom nebylo potřeba metodu implementovat. Knihovna si na základě názvu metody implementaci vygeneruje. Metodu lze modifikovat, aby vracela stránkovaný obsah:

\begin{lstlisting}[caption={Ukázka query metody pro dotazování se nad stránkovaným obsahem}, label={lst:repository-paging}, tabsize=2]
// Soubor VoteRepository.java
Page<Vote> findByElectionYear(int electionYear, Pageable pageable);
\end{lstlisting}

\noindent Lze i vytvořit komplexnější dotaz, který se dotazuje nad entitou na základě dvou podmínek:

\begin{lstlisting}[caption={Ukázka query metody s dvěma podmínkami}, label={lst:repository-paging}, tabsize=2]
// Soubor MembershipRepository.java
boolean existsByPersonIdAndAgencyId(int personId, int agencyId);
\end{lstlisting}

zdroj: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/


\section{Zpracování dat}
Backend každý den o půl noci aktualizuje databázi podle zdrojových dat na webu PSP. Aktualizace probíhá v následujících krocích:

\begin{itemize}
	\item \textbf{Stažení zdrojových souborů} - Zdrojové soubory jsou ve formátu zip a jsou stažené z webu PSP (https://www.psp.cz/sqw/hp.sqw?k=1300).
	\item \textbf{Extrakce datových souborů} - Ze zdrojových souborů jsou vyextrahovány datové soubory, které jsou ve formátu UNL.
	\item \textbf{Pročištění dat} - Některé datové soubory obsahují duplicitní záznamy. Ty jsou pro snadnější parsování odstraněny.
	\item \textbf{Parsování dat} - Datové soubory jsou zparsovány a načteny do Java objektů.
	\item \textbf{Transformace dat} -  Objekty jsou ztransformovány do požadované podoby.
	\item \textbf{Uložení dat do databáze} - Ztransfomovaná data jsou perzistentně uložena do databáze.
\end{itemize}

\subsection{Stahování zdrojových souborů}
Stahování zdrojových souborů má na starosti třída následující třída:

\begin{lstlisting}[caption={Třída pro stahování zdrojových souborů}, label={lst:psp-downloader}, tabsize=2]
// Soubor PspFilesDownloader.java
public class PspFilesDownloader {
	public static void downloadFiles() throws IOException {
		downloadHlasovani();
		downloadPoslanci();
	}

	// dalsi metody
}
\end{lstlisting}

\noindent Tato třída pro stahování souborů na základě URL interně používá knihovnu \lstinline|commons-io| (\ref{lst:common-io-downloader}). Knihovna poskytuje metodu \lstinline|copyURLToFile|, která akceptuje parametr pro URL zdrojového souboru a parametr pro lokální soubor, do kterého se má zdrojový soubor nakopírovat.

\begin{lstlisting}[caption={Ukázka stahování dat pomocí knihovny \lstinline|commons-io|}, label={lst:common-io-downloader}, tabsize=2]
// Soubor FileDownloader.java
public class FileDownloader {
	
	public static void download(
		String downloadUrlString, 
		String downloadDestination) {
		
		File file = new File(downloadDestination);
		URL downloadUrl = new URL(downloadUrlString);
		
		FileUtils.copyURLToFile(downloadUrl, file);
	
		...
	}
}
\end{lstlisting}

zdroj: https://commons.apache.org/proper/commons-io/

\subsection{Extrakce datových souborů}
Pro extrakci datových souborů byla použita knihovna \lstinline|zip4j|. Ta poskytuje třídu \lstinline|ZipFile| pro vytvoření objektu reprezentujícího lokální soubor ve formátu zip. Konstruktoru této třídy je předána lokace souboru v souborovém systému. Tato třída poskytuje metodu \lstinline|extractFile()| pro extrakci souborů ze zipu. Akceptuje tři parametry:

\begin{itemize}
	\item Název souboru, který se má vyextrahovat.
	\item Adresář, do které se má soubor vyextrahovaný soubor uložit.
	\item Výsledný název ukládaného souboru. V našem případě je stejný jako název před vyextrahováním souboru.
\end{itemize}

\noindent Zde je ukázka kódu pro popsanou extrakci souborů:

\begin{lstlisting}[caption={Ukázka extrakce souborů ze zipu}, label={lst:zip4j}, tabsize=2]
// Soubor ZipExtractor.java
public class ZipExtractor {

	public static void extract(
		String pathToZip, 
		String fileToExtract, 
		String destinationDir
	) {
		ZipFile zipFile = new ZipFile(pathToZip)
		zipFile.extractFile(fileToExtract, destinationDir, fileToExtract);
		
	}
		
}
\end{lstlisting}

zdroj: https://github.com/srikanth-lingala/zip4j

\subsection{Pročištění dat}
Některé datové soubory obsahují duplicitní záznamy. Ty jsou odstraněny pomocí skriptu napsaného v jazyce Bash:

\begin{lstlisting}[caption={Skript pro odstranění duplicitních řádků}, tabsize=2]
// Soubor removeDuplicates.sh.java
for FILE in "$1"/*; do
	sort "$FILE" | uniq > 'tmp.unl'
	mv 'tmp.unl' "$FILE"
	rm 'tmp.unl'
done
\end{lstlisting}

\noindent Skript funguje následovně:

\begin{itemize}
	\item Skript předpokládá ve svém prvním argumentu cestu ke adresáři, kde se nachází datové soubory.
	
	\item Na začátku se iteruje přes všechny soubory v daném adresáři.
	
	\item Každý soubor se pomocí příkazu \lstinline|sort| seřadí vzestupně podle abecedy.
	
	\item Ze seřazeného souboru se odstraní duplicitní řádky jdoucí za sebou pomocí příkazu \lstinline|uniq|. Vy tuto chvíli jsou ze souboru odstraněny všechny duplicity.
	
	\item Zbytek kódu již je pouze přesouvání obsahů souborů tak, aby datové soubory s odstraněnými duplicity měly jejich originální název.
\end{itemize}

\noindent Skript je volán ze souboru \lstinline|PspFilesCleaner|. Důvodem pro odstranění duplicit pomocí jazyka Bash a ne přímo pomocí Javy je to, že v Bashi jsou operace jednodušší a rychlejší než v Javě. 

\subsection{Parsování dat}
Pro parsování zdrojových dat používám knihovnu \lstinline|opencsv|. Ta umožňuje parsovat CSV soubory tak, že každý řádek v souboru namapuje na objekt. Mapování sloupců v souboru na atributy objektu je implementováno přidáním anotací k příslušným atributům. Vysvětlíme si na příkladu. Nejdříve je potřeba vytvořit třídu, do jejíž instancí se napamatují záznamy ve zdrojovém souboru. Ta bude mít u atributů anotaci určující pozici neboli číslo sloupce záznamu. Hodnota tohoto sloupce se pak napamatuje na tento atribut:

\begin{lstlisting}[caption={Parsování datového souboru omluvy.unl}, tabsize=2]
// Soubor Omluva.java
public class Omluva {
	@CsvBindByPosition(position = 0)
	private int idOrgan;
	
	@CsvBindByPosition(position = 1)
	private int idPoslanec;

	// dalsi atributy	
}
\end{lstlisting}

\noindent Nyní lze datový soubor zparsovat a namapovat na tuto třídu. Knihovna poskytuje třídu \lstinline|CsvToBeanBuilder|, které předáme objekt typu |Reader|. Ta slouží pro čtení znaků ze streamu. V tomto případě je do streamu posílány data z datového souboru. Třídá \lstinline|CsvToBeanBuilder| poskytuje metody, kterými specifikujeme:

\begin{itemize}
	\item Třídu, na kterou se mají záznamy namapovat.
	\item Oddělovač hodnot v záznamu.
	\item Určení, kdy je hodnota null. V tomto případě hodnota interpretována jako null, pokud je prázdná.
	\item Ignorování složených závorek.
\end{itemize}

\begin{lstlisting}[caption={Parsování datového souboru omluvy.unl}, tabsize=2]
// Soubor OmluvyParser.java
	
public class OmluvyParser extends UnlParser {
	
	public List<Omluva> read() {
		String filePath = PspPath.Unl.OMLUVY;
		BufferedReader reader = getReader(filePath);
		
		return new CsvToBeanBuilder<Omluva>(reader)
		.withType(Omluva.class)
		.withSeparator(UNL_SEPARATOR)
		.withFieldAsNull(UNL_NULL_SEPARATOR)
		.withIgnoreQuotations(true)
		.build()
		.parse();
		
	}
}
	
\end{lstlisting}

zdroj: https://opencsv.sourceforge.net/

\subsection{Transformace a uložení dat}
Po zpasrování datových souborů a namapování záznamů na objekty lze tyto objekty začít ztransformovat do žádané podoby. Kód pro transformaci má u všech typů dat podobný tvar:

\begin{lstlisting}[caption={Transformace objektu Omluva na databázový objekt Excuse}, tabsize=2]
// Soubor ExcuseLoader.java
	
public class ExcuseLoader extends BaseLoader {

    private final OmluvyParser omluvyReader;
    private final ExcuseRepository excuseRepository;

    public void load() {
			excuseRepository.deleteAllInBatch();
			List<Omluva> omluvaList = omluvyReader.read();
			
			List<Excuse> excuses = omluvaList.parallelStream()
						.map(omluva -> {
							// transformace
						})
					.collect(Collectors.toList());
				
			Lists
				.partition(excuses, BATCH_SIZE)
				.forEach(excuseRepository::saveAll);

	}

}
\end{lstlisting}

\noindent 
Před samotným parsováním jsou smazány všechny záznamy v příslušné tabulce. Poté probíhá parsování datových souborů a seznamu namapovaných objekt. Z tohoto seznamu je vytvořen paralelní stream, což stream, který potenciálně zpracuje objekt v seznamu paralelně. Každý objekt je ztransformován a namapován na databázový objekt. Konkrétní implementace transformace se liší od typu entity. Ztransformovaná data jsou perzistetně uložena do databáze. Ukládání je optimalizováno tak, že se neukládá po jednom ale po skupinách. Každá skupina obsahuje 1000 objektů. Ukládáme tedy po 1000 objektech.

