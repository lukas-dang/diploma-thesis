\chapter{Implementace mobilní aplikace}
\label{ch:implementation}

\begin{chapterabstract}
	V rámci této kapitoly bude popsána implementace mobilní aplikace. V první podkapitole budou popsány použité nástroje a technologie. Mobilní aplikace je implementována pomocí Googlem doporučené architektury pro vývoj mobilních aplikací (\ref{subsec:architecture-google}). Následující sekce budou rozděleny tak, aby odpovídaly jednotlivým vrstvám této architektury.
\end{chapterabstract}

\section{Použité nástroje a technologie}
V této sekci budou popsány hlavní nástroje a technologie použité pro implementaci mobilní aplikace.

\subsubsection *{Android Studio}
Mobilní aplikace byla vytvořena ve vývojovém prostředí Android Studio, což je oficiální IDE pro vývoj mobilních aplikací pro Android \cite{androidstudio}. Výhody tohoto IDE jsou:

\begin{itemize}
	\item \textbf{Podpora pro Android} - Android Studio je IDE určené pro vývoj mobilních aplikací pro Android. Po spuštění IDE se hned zobrazí průvodce pro instalaci Android SDK obsahující nástroje potřebné pro vývoj aplikací. Po instalaci je SDK připravené k použití. Není tedy potřeba SDK manuálně instalovat z internetu a naimportovat do IDE. IDE Dále poskytuje průvodce pro vytvoření projektu, pomocí kterého lze vybrat jednu z existujích šablon pro různé typy projektů. Po zvolení šablony IDE vytvoří projektový adresář se zdrojovými \linebreak kódy, závislostmi a konfiguračními soubory pro danou šablonu. Po vytvoření projektu je aplikace prázndá, ale je ve spustitelném stavu.
	
	\item \textbf{Emulátor} - Android Studio poskytuje vestavěný emulátor, který emuluje fyzické mobilní zařízení. Díky tomu může uživatel testovat své aplikace na různých zařízeních s různými konfiguracemi (např. různé rozměry zařízení, verze Androidu).
		
	\item \textbf{Klávesové zkratky} - Jeden z hlavních důvodů pro použití IDE založených od JetBrains jsou klávesové zkratky, které jsou stejné pro všechna IDE od JetBrains. Tyto zkratky zvyšují produktivitu vývojáře.
\end{itemize}

\subsubsection *{Gradle}
Gradle je nástroj pro automatizaci sestavování programu, tj. automatizace kompilace zdrojového kódu do binárního kódu, testování a zabalení do balíčku. Toto jsou další výhody Gradlu: 

\begin{itemize}
	\item \textbf{Gradle Pluginy} - Poskytují Gradlu další nástroje jako např. možnost kompilovat programovací jazyk Kotlin, parsovat anotace nebo generovat kód na základě konfiguračního souboru. 
	
	\item \textbf{Externí knihovny} - Pomocí Gradlu lze do aplikace přidat knihovny, které se stáhnou \linebreak z předem definovaného vzdáleného repozitáře.
	
	\item \textbf{Konfigurace} - Gradle umožňuje konfigurovat pluginy a aplikaci. U Androidu lze nakonfigurovat např. SDK verzi, verzi Kotlinu, aktivaci Jetpack Compose toolkitu (\ref{ssec:jetpack-compose}).
\end{itemize}

\noindent Alternativou je nástroj Maven, který lze také použít pro vývoj mobilní aplikace pro Android. Oba mají své výhody a nevýhody pro různé situace. Rozhodl jsem se však pro Gradle, jelikož při vytváření projektu v Android Studiu nebyla možnost výběru mezi Gradlem a Mavenem. Projekt byl automaticky nakonfigurován pomocí Gradlu. Předpokládám tedy, že Google preferuje Gradle jako nástroj pro vývoj v Androidích aplikací. Maven by se musel nakonfigurovat manuálně, což by pro zprovoznění aplikace bylo časově náročné, a nejspíš i zbytečné.

\subsection *{Kotlin}
Pro mobilní aplikaci byl použit programovací jayzk Kotlin \cite{kotlin}, který je od roku 2017 preferovaným jazykem pro Android \cite{google-prefers-kotlin}. Původním programovacím jayzkem pro Android byla Java \cite{java}. Kotlin má však oproti němu několik výhod:

\begin{itemize}
    \item \textbf{Je stručný} - Kotlin umožňuje např. vytvořit 
    singleton pomocí klíčového slova \lstinline{object} \cite{kotlin-object}.
    
    \item \textbf{Je bezpečný} - Kotlin rozlišuje null a non-null datové typy. Non-null typy lze dereferencovat vždy, null typy pouze po kontrole výskytu hodnoty null. To je vynuceno typovým systémem Kotlinu. Díky tomu není možné zkompilovat kód, v kterém by se dereferencovala hodnota null, kvůli čemuž by aplikace spadla.
    
    \item \textbf{Je expresivní} - Kotlin byl navržen s důrazem na stručnost a výstižnost kódu.
\end{itemize}

\subsubsection*{Kotlin Coroutines}

\noindent Dalším důvodem pro použití Kotlinu souvisí s dlouze běžícími blokujícími operacemi jako např. síťovými a databázovými operacemi. Android aplikace běží defaultně na hlavním vláknu, které má na starosti vykreslování obrazovky a obsluhu událostí. Pokud je na tomto vlákně provedena dlouze běžící blokující operaci, vlákno se zablokuje na delší dobu a nebude moct obsluhovat události. Uživatelovi se aplikace pak jeví jako zamrznutá. Jedním řešením pro tento problém je vytvořit nové vlákno a provést operaci na něm. Dvě různá vlákna běží paralelně, a tudíž operace běžící na nově vytvořeném vlákně nebude blokovat hlavní vlákno, a tudíž aplikace nezamrzne. Problémem však je, že tvorba vláken a jejich správa jsou drahé operace. 

Alternativním řešením jsou Kotlin Coroutines - paměťově nenáročný způsob, jak psát paralelní kód. Přesné fungování coroutinů je nad rámec této práce, pro účely této práce však stačí vědět, že coroutines se chovají paměťově nenáročná vlákna. To znamená, že lze vytvořit několik coroutinů, z nichž každý reprezentuje nějaký kus paralelně běžícího výpočtu. Oproti vláknům lze coroutinů spustit mnohem více (na běžném počítači klidne v řádu stovek nebo tisíců). Zde je příklad použití coroutiny:

\newpage

\begin{lstlisting}[caption={Příklad použití coroutiny}, label={lst:coroutine-example}, tabsize=2, language=Kotlin]
// Soubor ListViewModel.kt
class ListViewModel {

	// zbytek implementace

	init {
		viewModelScope.launch {
			// paralelne bezici operace 1
		}
		
		viewModelScope.launch {
			// paralelne bezici operace 2
		}
	}

	// zbytek implementace
}
\end{lstlisting}

\noindent V tomto kusu kódu je coroutina pro operaci 1 vytvářena zavoláním funkce \lstinline|launch| na objektu \lstinline|viewModelScope|. Funkce akceptuje callback funkci, která bude zavolána v rámci vytvořené couroutiny. To znamená, že callback funkce bude běžet paralelně vzhledem k ostatním  coroutinám, v tomto případě vzhledem ke coroutině spouštějící druhou operaci. Důležité je, že obě coroutiny běží paralelně, ale na stejném vlákně. Dále objekt \lstinline|viewModelScope| určuje scope, v kterém běží coroutina. Ten určuje životní cyklus dané coroutiny. Pokud skončí scope a coroutina ještě nedoběhla, coroutina automaticky ukončí svůj běh. Jednoduchým příkladem scopu je scope samotné aplikace. Pokud je aplikace spuštěna, pak scope existuje a coroutina může běžet. Pokud je aplikace zavřena, scope přestane existovat a coroutina přestane běžet. Díky tomu lze předejít únikům dat. Když by byla aplikace zavřena a scope by stále existoval, pak by coroutina stále \linebreak běžela, a až by doběhla, mohla by nějakým způsobem modifikovat data nebo data někám přidávat. při opětovném spuštění aplikace však jsou reference na tato data ztracena.

Další důležitou vlastností coroutinů je to, že callback funkce, kterou volá, je suspendovatelná. To znamená několik věcí

\begin{itemize}
	\item Deklare funkce je označená klíčovým slovem \lstinline|suspend|
	\item Suspendovatelná funkce může volat ostatní suspendovatelné funkce. Naopak nesuspendovatelná funkce může volat \textbf{pouze} nesuspendovatelné funkce.
	\item Suspendovatelná funkce může coroutinu suspendovat, tj. pozastavit ji, a uvolnit tím vlákno pro použití jinou coroutinou.
\end{itemize}

\noindent Důležitý je třetí bod. Díky mechanizmu pro suspendování coroutiny mohou coroutiny bežět paralelně. Příklad suspendovatelné funkce, která suspenduje coroutinu, je funkce \lstinline|delay()|, která coroutinu suspenduje na určitý počet milisekund. Během této doby je vlákno uvolněno pro použití jinou coroutinou. Jakmile uběhne daný časový interval, coroutina pokračuje ve svém běhu. Častějším případem použití je např. zavolání síťové operace prostřednictvím knihovny ze třetí \linebreak strany, která poskytuje suspendovatelné funkce, v rámci kterých je interně implementován suspendovací mechanizmus. Tedy jakmile se provede síťová operace a čeká se na výsledek, knihovna coroutinu sama suspenduje. Uživatel tím pádem nemusí manuálně suspendovat coroutinu po zavolání dlouze běžící operace, ale pouze zavolá funkci knihovny, a ta se postará o zbytek. Tato knihovna bude detailněji popsána v (\ref{sec:impl-network}).

\subsection*{Kotlin Flow}
Kotlin Flow \cite{kotlinflow} je datový typ, který reprezentuje asynchronní proud hodnot, který poskytuje data v čase. Funguje tak, že klientský kód se k proudu zaregistruje, a stane se konzumentem dané flow. Kód produkující nové hodnoty a vkládající je do tohoto proudu je producentem dané flow. Jakmile producent vyprodukuje novou hodnotu a vloží ji do proudu, konzument hodnotu automaticky zkonzumuje, a na základě ní provede nějakou akci. Produkce hodnot nezačíná \linebreak tehdy, když je vytvořena flow, ale až když se k ní konzument explicitně (pomocí funkce) zaregistruje a začne ji konzumovat. Flow je asynchronní proud hodnot, tj. hodnoty proudu jsou produkovány asynchronním způsobem (např. jsou získávány vzdáleně z backendu). Pro asynchronní produkci dat se používají coroutiny. Flow může být filtrována a transformována, tj. její hodnoty mohou být namapovány na jiné. Různé flow mohou být mezi sebou kombinovány, aby konzument mohl pracovat s hodnotami obou flowů zároveň. Lze nastavit, zda má konzument zareagovat na produkci nových hodnot v obou flowů zároveň nebo jenom jednoho z flowů. Všechny zmíněné operace na flowech lze provést zavoláním funkcí na dané flow a lze je řetězit. Zde je příklad flow, která produkuje seznam hlasování:

\begin{lstlisting}[caption={Příklad použití flow}, label={lst:flow-general}, tabsize=2, language=Kotlin]
	
// Soubor VoteListViewModel.kt
class VoteListViewModel: ViewModel() {
	
	// zbytek implementace
	
	private val _currentElectionYear = MutableStateFlow(2021)	
	val currentElectionYear: StateFlow<Int> = _currentElectionYear
	
	private val _searchText = MutableStateFlow("")
	val searchText: StateFlow<String> = _searchText
	
	init {
		viewModelScope.launch {
			currentElectionYear.combine(searchText, ::Pair)
			.collectLatest { pair ->
				// zde jsou konzumovany hodnoty pair
				// zde jsou provadeny dalsi operace nad hodnotou pair
			}
		}
	}

	fun onSearchTextChange(newText: String) {
		_searchText.value = newText
	}

	// zbytek implementace
}
\end{lstlisting}

\noindent Flow produkuje data asynchronně pomocí coroutinů a každá coroutina musí běžet v nějakém scopu, tudíž každá registrace konzumenta k flow musí proběhnout ve scopu. V tomto případě je použit scope \lstinline|viewModelScope|, což je scope jendoho z komponentu Androidu, view modelu, který bude vysvětlen později. V rámci coroutiny jsou kombinovány dvě flowy, \lstinline|currentElectionYear| \linebreak a \lstinline|searchText|, do jednoho flowu produkující pár hodnot. Toho je dosaženo pomocí funkce \lstinline|combine| s parametrem \lstinline|::Pair|, což je reference na konstruktor třídy \lstinline|Pair|, pomocí kterého se vytváří flow párů. Všimněme si, že datovými typy flowů je \lstinline|StateFlow|. Existence těchto flowů je závislé na životním cyklu Android komponenty, v kterém běží. V tomto případě běží ve view modelu, který ještě existuje v rámci životního cyklu jiné Android komponenty. Pokud jedna z těchto komponent je po konci svého životního cyklu, všechny \lstinline|StateFlow| přestanou produkovat hodnoty a jsou odebrány z paměti. Po zkombinování dvou různých flow do jedné je výsledné flow konzumováno pomocí funkce \lstinline|collectLatest|. V tuto chvíli může začít produkce hodnot. Jak jde však vidět, tak první flow produkuje na začátku pouze jednu hodnotu 2021 a druhá flow pouze prázdný řetězec "". Další produkce dat může proběhnout buď v reakci na nějakou událost (např. kliknutí na tlačítko nebo psaní) nebo na načtení dat ze sítě, databáze, lokálního úložiště atd. Příklad kódu produkující data pro flow je funkce \lstinline|onSearchTextChange|, která do dané flow jednoduše uloží novou hodnotu. V tuto chvíli chceme, aby se zavolala callback funkce uvnitř \lstinline|collectLatest|. Nemusíme ji však zavolat přímo, konzument totiž na změnu hodnoty ve flow zareaguje a spustí daný kód sám. Kotlin Flows mají tedy následující výhody:

\begin{itemize}
	\item Proud hodnot je asynchronní a založený na paměťově nenáročných coroutinech.
	
	\item Proudy lze elegantním způsobem filtrovat a transformovat. Tyto operace lze řetězit.
	
	\item Produkce nové hodnoty v proudu automaticky spustí kód konzumenta tohoto proudu.
	
	\item Kód je čitelnější.
\end{itemize}


\subsection *{Android komponenty}
Android komponenta \cite{android-component-application} je hlavním stavením kamenem aplikace, která má na starosti určitou funkcionalitu. V aplikaci se používá pouze komponenta \lstinline|Application|. Pro jednoduchost textu budou považovány za komponenty i \lstinline|Activity| a \lstinline|ViewModel|, přestože podle dokumentace nejsou považovány za Android komponenty jako takové. V aplikaci jsou tedy použity následující komponenty:

\begin{itemize}
	\item \textbf{Application} - Reprezentuje aplikaci. Slouží pro inicilizaci aplikace a správu globálního stavu \cite{android-component-application}. je inicializována před ostatními Android komponentami. Všechny ostatní Android komponenty existují v rámcí této. Pro použití vytvoříme podtřídu třídy \lstinline|Application| a specifikujeme cestu k této podtřídě v rámci souboru \lstinline|AndroidManifest.xml|.
	
	\item \textbf{Activity} - Reprezentuje obrazovku a má na starosti správu UI a obsluhu událostí. Je to vstupní bod pro vytvoření UI. V aplikaci je použita pouze jedna aktivita a v rámci ní je dynamicky měněn obsah. Při navigace na jinou obrazovku se tedy nevytvoří nová aktivita, ale změní se pouze obsah existující aktivity. Pro použití této komponenty vytvoříme podtřídu třídy \lstinline|ComponentActivity| a specifikujeme cestu k této podtřídě v rámci souboru \lstinline|AndroidManfiest.xml|.
	
	\item \textbf{ViewModel} - Reprezentuje držitele stavu (\ref{fig:android-architecture-ui}), tj. definuje business logiku a drží v sobě stav pro UI elementy. Změna stavu vyvolá opětovné vykreslení UI. Pro použití této třídy vytvoříme podtřídu třídy \lstinline|ViewModel|.
\end{itemize}

\subsection *{Hilt}
Hilt je dependency injection (dále jen DI) knihovna pro Android, která umožňuje přidat závislosti (dále jen injektovat) objektům pomocí anotací. Vysvětlíme si na příkladě:

\newpage

\begin{lstlisting}[caption={Příklad použití DI pomocí knihovny Hilt}, label={lst:hilt-di}, tabsize=2, language=Kotlin]
// Soubor VoteListViewModel.kt
@HiltViewModel
class VoteListViewModel @Inject constructor(
	private val getVotes: GetVotesUseCase,
	// dalsi zavislosti
) {	
	// implementace tridy
}
\end{lstlisting}

\noindent Tento kód reprezentuje view model s jednou závislostí ve svém konstruktoru. Díky anotacím  \lstinline|@HiltViewModel| a \lstinline|@Inject| z knihovny Hilt je uvedená závislost do tohoto objektu automaticky injektována Hiltem. Danou závislost nalezne Hilt ve svém interním kontejneru, který obsahuje všechny objekty a jejich závislostmi, které chceme, aby byly injektovatelné. Předpokladem pro DI je tedy existence tohoto interního kontejneru s grafem závislostí. Ten je nainicializován na základě konfiguračního souboru, v kterém specifikujeme objekty a jejich závislosti, které se mají do daného kontejneru přidat. Příkladem takové konfigurace je:

\begin{lstlisting}[caption={Ukázka konfigurace DI pro Hilt}, label={lst:hilt-config}, tabsize=2, language=Kotlin]
// Soubor UseCaseModule.kt

@Module
@InstallIn(ViewModelComponent::class)
object UseCaseModule {	
	
	@Provides
	fun provideGetVotesUseCase(
		voteRepository: VoteRepository,
	): GetVotesUseCase {
		return GetVotesUseCase(voteRepository)
	}

	// dalsi konfigurace zavislosti
}
\end{lstlisting}

\noindent Konfigurace je specifikována v rámci singletonu. Anotace \lstinline|@Module| říká, že daný objekt obsahuje konfigurace závislostí, která má Hilt přidat do svého grafu závislostí. Pomocí anotace \lstinline|@InstallIn| specifikujeme životní cyklus pro dané závislosti. V tomto případě jsou závislosti vázané na životní cyklus view modelu. Pomocí anotace \lstinline|Provides| specifikujeme již danou závislost. V tomto případě funkce vrací objekt typu \lstinline|GetVotesUseCase|, a tím pádem je tento objekt Hiltem přidán do grafu závislostí a může být injektován do kteréhokoliv objektu. Všimněme si, že tento objekt má závislost na objektu typu \lstinline|VoteRepository|. Tato závislost je také Hiltem injektována. Závislost je nakonfigurována podobným způsobem akorát v jiném souboru. Výhody DI jsou:

\begin{itemize}
	\item \textbf{Loose coupling} - Závislostí objektu nemusí být nutně třídá, ale nějaké rozhraní. Díky tomu objekt nezávisí na konkrétní implementaci třídy, ale akceptuje různé implementace daného rozhraní. Tyto implementace jsou dodány Hiltem a nakonfigurovány v konfiguračním souboru. Zdrojový kód aplikace je tedy upuštěn od nutnosti specifikovat konkrétní implementace rozhraní. Komponenty aplikace jsou díky tomu na sobě relativně nezávislé, protože závisí pouze na rozhraních. 
	
	\item \textbf{Znovupoužitelnost} - Komponenty, které závisí na rozhraních, jsou snadno znovupoužitelné.
	
	\item \textbf{Snazší testování} - Při testování funkčnosti aplikace jsou pro závislosti často používány mockovací objekty, které simulují chování skutečného objektu. Díky závislosti objektu pouze na rozhraní, lze za dané rozhraní snadno injektovat vlastní testovací implementaci. 
\end{itemize}

\subsection*{Jetpack Compose}
\label{ssec:jetpack-compose}
Jetpack Compose je Googlem doporučený způsob pro implementaci uživatelského rozhraní \cite{jetpack-compose}. UI je implementováno pomocí programového kódu voláním \textit{composable} funkcí, které reprezentují a na základě kterých se vykreslí nějaký UI element na obrazovce, ať už to je pouze tlačítko nebo celá obrazovka. Jetpack Compose poskytuje nativní composable funkce např. pro tlačítko, text a obrázek, ale také funkce reprezentující kontejnery pro seskupení UI elementů např. do řádku nebo sloupce. Kombinací těchto funkcí lze vytvořit složitější funkce reprezentující složitější UI elementy. Jelikož UI elementy jsou reprezentovány funkcemi, lze je přepoužívat na více místech zavoláním dané funkce. Pomocí parametrů funkcí lze měnit vzhled a chování UI elementu. Lze mu např. změnit barvu, textový obsah, ale také přidat obsluhu pro události jako kliknutí na daný element a scrollování scrollovatelným kontejnerem. Jelikož je UI popisováno v programovým jazyce, lze využít jeho programové konstruktury jako cykly a podmínky. Zde je příklad composable funkce:

\begin{lstlisting}[caption={Ukázka composable funkce}, label={lst:composable-example}, tabsize=2, language=Kotlin]
// Soubor VoteListScreen.kt

@Composable
private fun Metadata(
	modifier: Modifier = Modifier,
	vote: Vote?,
) {
	Column(modifier = modifier) {
		Description(vote?.description ?: "")
		Spacer(Modifier.height(15.dp))
		DateAndTime(vote?.date ?: "")

		// dalsi volani composable funkci
	}
}

@Composable
fun Description(description: String) {
	Text(
		text = description,
		// dalsi atributy
	)
}

\end{lstlisting}

\noindent Composable funkce jsou označené anotací \lstinline|@Composable|, aby je mohl Jetpack Compose detekovat. Funkce \lstinline|Metadata| volá nativní composable funkci \lstinline|inline|, která repezentuje sloupec UI elementů. Parametr \lstinline|modifier| akceptuje objekt typu \lstinline|Modifier|, který obsahuje informace o vzhledu a chování dané komponenty. Nemusí to však být jediný parametr pro tento účel. V rámci funkce \lstinline|Column| jsou volány další tři composable funkce, které jsou vykreslovány pod sebou. \lstinline|Description| je vlastně definovaná composable funkce, která volá nativní composable funkci \lstinline|Text| repezentující textový obsah. \lstinline|Spacer| je nativní composable funkce, která vytvoří mezeru o velikosti 15 pixelů. Implementace composable funkce \lstinline|DateAndtime| zde pro stručnost není uvedena, ale je to stejně jako funkce \lstinline|Description| vlastně definovaná composable funkce. Všimněme si, že composable funkce můžeme pojmenovat podle jejich účelu. Např. funkce \lstinline|Description| reprezentuje popis a funkce \lstinline|DateAndTime| reprezentuje datum a čas. Dalšími důležitými koncepty composable funkcí jsou lokální stav a rekompozice composable funkcí, které budou vysvětleny na následujícím příkladu:

\newpage

\begin{lstlisting}[caption={Ukázka composable funkce}, label={lst:composable-example}, tabsize=2, language=Kotlin]
// Soubor VoteDetailsScreen.kt

@Composable
fun VoteDetailsScreen(
	viewModel: VoteDetailsViewModel = hiltViewModel(),
	// zbytek parametru
) {
	
	// zbytek implementace
	
	val voteDetailsUiState by 
		viewModel.voteDetailsUiState.collectAsStateWithLifecycle()
	
	Info(voteDetailsUiState = voteDetailsUiState)
}
\end{lstlisting}

\noindent Tento kód obsahuje composable funkci pro vykreslení obrazovky pro detail hlasování. Funkce obsahuje argument \lstinline|viewModel| a proměnnou \lstinline|voteDetailsUiState|. Nezávislě na tom, co tyto hodnoty přesně znamenají, dochází při jejich změně k rekompozici funkce. To znamená, že je funkce knihovnou Jetpack Compose znovu zavolána, ale tentokrát s novými daty. Důležitou vlastností composable funkcí je to, že k rekompozici dochází pouze ve všech funkcí v rámci podstromu \linebreak funkce, kde došlo ke změně stavu. Další poznámkou je, že návratový typ funkce \linebreak \lstinline|collectAsStateWithLifecycle()|, která bude vysvětlena v popisu implementace prezentační \linebreak vrstvy, je obecně \lstinline|State<T>|, kde T je nějaký argument datového typu. Aby změna lokální proměnné vyvolala rekompozici funkce, musí být tohoto datového typu. Ke konkrétní hodnotě typu \lstinline|T| se lze pak dostat prostřednictvím atributu \lstinline|value| třídy \lstinline|State|. Díky klíčovému slovu \lstinline|by| má proměnná \lstinline|voteDetailsUiState| datový typ \lstinline|T|, a tudíž lze k ní přistupovat přímo. Mechanizmus rekompozice je přitom zachována. Výhody použití knihovny Jetpack Compose jsou tedy následující:

\begin{itemize}
	\item \textbf{Deklarativní popis UI} -- Popisujeme, jak má vypada UI a jaké jsou jeho stavy. Nepopisujeme, jak se má vytvořit UI. Díky tomu je kód pro popis UI čitelnější a UI se automaticky znovu vykreslí v reakci na změnu stavu UI.
	
	\item \textbf{Stručnost a výstižnost} -- Kód je stručnější a výstižnější než při použití XML layoutů, který je popsán níže.
	
	\item \textbf{Efektivní vykreslování} -- Díky cílené rekompozici je znovu vykreslována pouze ta část \linebreak UI, u které se změnil stav dat.
	
	\item \textbf{Jednoduché testování} -- Jetpack Compose umožňuje jednoduše testovat UI, jak bude ukázáno v kapitole testování.
\end{itemize}

\noindent Alternativou ke knihovně Jetpack Compose pro vytváření UI jsou XML layouty, pomocí kterých lze vytvářet UI prostřednictvím XML tagů v XML souborech. Hlavní myšlenkou tohoto přístupu je to, že oddělujeme popis uživatelského rozhraní od programového kódu, díky čemuž je kód čitelnější a udržitelnější. XML soubory obsahují pouze popis elementů. Programový kód pracuje pouze s částmi aplikace mimo UI. Míchání popisu UI a programového kódu se však nikdy nevyhneme, jelikož layoutům se musí minimálně předat aspoň data. Toho lze dosáhnout pouze propojením programového kódu s layoutem. Dále např. implementace dynamického seznamu pomocí XML layoutu vyžaduje hodně boilerplate kódu \cite{recycler-view}. Pro Jetpack Composu je vytvoření takového seznamu otázkou pár řádků kódu \cite{lazy-column}. Z toho důvodu jsem se rozhodl implementovat UI pomocí knihovny Jetpack Compose.

\subsection*  {Proto DataStore}
V aplikaci je možnost nastavit si aktuální volební období. Toto nastavení by si měla aplikace pamatovat i po vypnutí a opětovném aplikace. Z toho důvodu je tento údaj ukládán lokálně \linebreak v mobilním zařízení. Jsou dvě různé knihovny, které poskytují rozhraní pro ukládání do lokálního úložiště a čtení z něj: \lstinline|SharedPreferences| \cite{shared-preferences} a \lstinline|DataStore| \cite{data-store}. Knihovna \lstinline|DataStore| poskytuje asynchronní práci s lokálním úložištěm pomocí couroutinů, knihovna \lstinline|SharedPreferences| pouze synchronní. Z toho důvodu byl vybrán \lstinline|DataStore|. Knihovna \lstinline|DataStore| poslytuje dvě různé implementace: \lstinline|Preferences DataStore| a \lstinline|Proto DataStore|. Implementace \lstinline|Proto DataStore| ukládá data jako instance vlastně definované třídy, která je vytvořena na základě konfiguračního souboru napsaný v jazyce používaného v \lstinline|Protocol Buffers|. Díky implementace přes třídu je při ukládání a čtení dat poskytována typová kontrola. Implementace \lstinline|Preferences DataStore| umožňuje přistupovat k datům pomocí klíčů, nevyžaduje předem definované schéma pro data a neposkytuje typovou kontrolu. Kvůli absenci typové kontroly \lstinline|Preferences DataStore| byla zvolena implementace \lstinline|Proto DataStore|, která funguje následovně:

\begin{lstlisting}[caption={Ukázka práce s Proto DataStore}, label={lst:proto-datastore}, tabsize=2, language=Kotlin]
// Soubor user_prefs.proto
message UserPreferences {
	int32 election_year = 1;
}

// Soubor UserPreferencesRepository.kt
class UserPreferencesRepository(
	private val userPreferencesStore: DataStore<UserPreferences>
) {
	
	val userPreferencesFlow: Flow<UserPreferences> = 
		userPreferencesStore.data
		// dalsi manipulace s flowem pro osetreni chyb
	
	suspend fun updateElectionYear(year: Int) {
		userPreferencesStore.updateData { preferences ->
			preferences.toBuilder().setElectionYear(year).build()
		}
	}
}
\end{lstlisting}

\noindent Zpráva, jak ji nazývá Google, \lstinline|DataStore| repezentuje strukturu lokálního úložiště. Na základě ní se při sestavení aplikace vygeneruje třídá \lstinline|UserPreferences|. Třída \lstinline|DataStore| poskytuje rozhraní pro práci s lokálním úložištěm. Proměnná \lstinline|userPreferencesDataStore.data| je flow poskytující data z lokálního úložiště, tj. jakmile se data v úložišti změní, konzument dané flow na to zareaguje. Přes tuto proměnnou lze tedy získat aktuální volební rok. Pro aktualizaci volebního roku je pak použita funkce \lstinline|updateElectionYear|.

\section {Implementace prezentační vrstvy}
Popis implementace prezentační vrstvy bude rozdělena na popis vstupního bodu do \linebreak aplikace, popis implementace UI elementů a popis držitelů stavu.

\subsection*{Vstupní bod}
Vstupním bodem je třída \lstinline|MainActivity|, která dědí ze třídy \lstinline|Activity|. Reprezentuje tedy obrazovku. Jelikož používáme Jetpack Compose, je použita pouze jedna aktivita a v rámci ní bude dynamicky měněn obsah. Tato třída je Android komponenta, a proto má životní cyklus. Nás zajímá především fáze životního cyklu, kdy je aktivita vytvořena. Jakmile se aktivita nachází v této fázi, zavolá se její funkce \lstinline|onCreate()|, kterou lze v podtřídě přepsat. V této funkce je inicializována aplikace a zavolána kořenová composable funkce:

\begin{lstlisting}[caption={Třída activity}, tabsize=2, language=Kotlin]
// Soubor MainActivity.kt

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
	
	// zbytek implementace
	
	override fun onCreate(savedInstanceState: Bundle?) {
		super.onCreate(savedInstanceState)
		
		init()
		
		setContent {
			PspApp()
		}
	}

	// zbytek implementace
}
\end{lstlisting}

\noindent Anotace \lstinline|@AndroidEntryPoint| je informace pro Hilt, aby dovoloval injetovat závislosti v rámci této třídy a všech komponent existujících v rámci této aktivity. Pomocí funkce \lstinline|setContent| je zavolána kořenová composable funkce \lstinline|PspApp|. V rámci funkce \lstinline|init| je z backendu získán seznam volebních roků a uložen do lokálního úložiště:

\newpage

\begin{lstlisting}[caption={Třída activity}, tabsize=2, language=Kotlin]
// Soubor MainActivity.kt

@Inject
lateinit var userPreferencesRepository: UserPreferencesRepository

@Inject
lateinit var pspApi: PspApi

private fun init() {
	initUserPreferences()
}

private fun initUserPreferences() {
	lifecycleScope.launch {
		userPreferencesRepository.userPreferencesFlow.collect { 
			userPreferences ->
			if (userPreferences.electionYear == 0) {
				try {
					val appState = pspApi.getAppState()
					userPreferencesRepository
						.updateElectionYear(appState.electionYears.first())
				} catch (_: IOException) {
				}
			}
		}
	}
}
\end{lstlisting}

\noindent Operace stahování dat z backendu a uložení do lokálního úložiště jsou blokující operace, a tudíž je voláme v rámci coroutiny prostřednictvím funkce \lstinline|lifecycleScope.launch|, kde \lstinline|lifecycleScope| je scope aktivity. Data s volebními roky jsou získávána z backendu a uložena do lokálního úložiště.

\subsection*{UI elementy}

UI bylo implementováno pomocí knihovny Jetpack Compose. Zde je výčet některých použitých composable funkcí a jejich popisů:


\begin{itemize}
	\item \textbf{Column} - Sloupcový kontejner pro elementy. Hodí se pro pozicování UI elementů do sloupce. Nehodí se pro dlouhé seznamy, jelikož při rekompozici této komponenty dojde k rekompzici všech jejích podkompoennt, včetně těch které nejsou na obrazovce viditelné kvůli velikosti seznamu. Kontejnerem nejde scrollovat. Používám ji pozicování všech elementů, které se nachází pod sebou.

	\item \textbf{LazyColumn} - Sloupcový kontejner pro elementy, který je zoptimalizovaný pro dlouhé seznamy. Při rekompozici komponenty dojde k rekompozici pouze viditelných podkomponent. Kontejnerem lze scrollovat. Používám ji pro dlouhé seznamy, tj. seznam hlasování, seznam poslanců, hlasování jednotlivých klubů a hlasování poslance.

	\item \textbf{Row} - Řádkový kontejner pro elementy. Používám ji pro pozicování komponent vedle sebe.

	\item \textbf{Text} - Textový element. Používám ji pro zobrazení textového obsahu.

	\item \textbf{Image} - Obrázkový element. Obrázek lze získat pomocí URL adresy. Používám ho pro zobrazení profilových fotek poslanců a logy klubů.

	\item \textbf{Icon} - Komponenta pro ikonku. Používám ji např. pro ikonky v hlavičce a v dolní liště.

	\item \textbf{IconButton} - Tlačítko s ikonkou uprostřed. Používám ho pro vyhledávací tlačítko.

	\item \textbf{OutlinedButton} - Tlačítko s kontrastem barev mezi pozadím a obvodem. Používám ho pro tlačíka v popupu na obrazovce nastavení.

	\item \textbf{OutlinedTextField} - Textové pole s kontrastem barev mezi pozadím a obvodem. Používám ho pro vyhledávací pole.

	\item \textbf{FloatingActionButton} - Plovoucí tlačítko. Používám ho pro skok na začátek dlouhých seznamu.

	\item \textbf{Scaffold} - Pomocný kontejner pro seskupení komponent na obrazovce. Umožňuje jednoduchým způsobem přidat plovoucí tlačítko a automaticky ho napozicovat. Používám jeden sdílený všemi mezi obrazovkami. Každá obrazovka s dlouhým seznamem má taktéž tuto komponentu pro přidání plovoucího tlačítka.

	\item \textbf{TopAppBar} - Horní lišta.

	\item \textbf{Spacer} - Vytváří mezeru mezi dvěma UI elementy. zda je mezera horizontální nebo veritkální, specifikujeme skrz parametr.

	\item \textbf{Divider} - Oddělovač. Dá se nastavit na vertikální nebo horizontální.

	\item \textbf{CompositionLocalProvider} - Umožňuje přepsat hodnotu v kontextu, který obsahuje globální hodnoty dostupné v rámci určitého podstromu komponent. Používám ji pro lokální přepsání globální barvy, a tím nastylování textů pro data a časy.

	\item \textbf{Box} - Kontejner umožňující skládat UI elementy na sebe. Používám ho pro vytvoření popupu v nastavení. Na pozadí je seznam nastavení a na něm se leží daný popup.

	\item \textbf{SettingsMenuLink} - Composable funkce z knihovny Alorma pro snadné vytvoření nastavení v seznamu nastavení s již nějakým defaultním nastylováním.

	\item \textbf{ListItemPicker} - Composable funkce z knihovny Alorma reprezentující seznam \linebreak hodnot, kterým lze scrollovat. Knihovna ji definuje defaultní vzhled.

	\item \textbf{Card} - Karta obsahující libovolný obsah a prvek pro akci. Používám ji např. pro elementy \linebreak v seznamu hlasování.

	\item \textbf{TabRow} - Lišta s taby. Používám ji na obrazovce pro detail hlasování a na obrazovce pro detail poslance.

	\item \textbf{Tab} - Reprezentuje konkrétní obrazovku v rámci tabu.

	\item \textbf{HorizontalPager} - Layout umožňující horizontálně scrollovat obsahem. Používám ho pro scrollování mezi taby.
\end{itemize}

\noindent Zde je seznam souborů, v kterých je vytvářeno UI. Každý z těchto souborů odpovídá jedné obrazovce:

\begin{itemize}
	\item \textbf{VoteListScreen.kt}
	\item \textbf{VoteScreen.kt}
	\item \textbf{MemberListScreen.kt}
	\item \textbf{MemberScreen.kt}
	\item \textbf{SettingsScreen.kt}
\end{itemize}

\noindent Všechny UI komponenty v jiných souborech jsou používány v rámci UI komponent v těchto souborů. Každá komponenta je implementována podobně. Nejdřív jsou definován stav funkce \linebreak a poté následuje popis UI. Např. UI komponenta pro seznam hlasování vypadá následovně:

\begin{lstlisting}[caption={Komponenta pro seznam hlasování, language=Kotlin}, tabsize=2, language=Kotlin]
// Soubor VoteListScreen.kt.kt
	
@Composable
fun VoteListScreen(
	modifier: Modifier = Modifier,
	onVoteClick: (id: Int) -> Unit,
	viewModel: VoteListViewModel = hiltViewModel()
) {
	val fetchState by viewModel.fetchState
	val refreshing by viewModel.isRefreshing
	val pullRefreshState = rememberPullRefreshState(
		refreshing,
	{ viewModel.refresh() }
	)
	
	val votePagingItems = viewModel.votes.collectAsLazyPagingItems()
	
	val searchText by viewModel.searchText.collectAsStateWithLifecycle()
	val isSearchBarExpanded = viewModel.isSearchBarExpanded.value
	
	val electionYearRange by 
		viewModel.electionYearRange.collectAsStateWithLifecycle("")
	
	Column(modifier = modifier) {
		// zbytek implementace
	}
\end{lstlisting}

\noindent Na začátku funkce je definován stav:

\begin{itemize}
	\item \textbf{fetchState} -- Příznak pro zjištění stavu, zda je přístup k backend v pořádku nebo zda nastal nějaký problém jako např. backend hází chybu 500 nebo mobilní zařízení není připojeno \linebreak k internetu.
	
	\item \textbf{refreshing} -- Příznak, zda je seznam obnovován, tj. zda jsou data z backendu opětovně stahována. Toho lze dosáhnout táhnutím obrazovky dolu.
	
	\item \textbf{pullRefreshState} -- Stav pro obnovy. Tento objekt je z externí knihovny material a má na starosti sledování události pro táhnutí obrazovkou dolu.
	
	\item \textbf{votePagingItems} -- Stránkovaný seznam hlasování.
	
	\item \textbf{searchText} -- Aktuálně napsaný text ve vyhledávacím poli.
	
	\item \textbf{isSearchBarExpanded} -- Příznak, zda je vyhledávací pole expandováno.
	
	\item \textbf{electionYearRange} -- Textová reprezentace volebního období.
\end{itemize}

\noindent Po definici stavu je vytvářeno samotné UI využitím daných stavů. Komponenta pro seznam poslanců vypadá téměř stejně. Ostatní komponenty jsou psány stejným stylem. Navigace je implementována pomocí UI komponenty \lstinline|NavHost|:

\begin{lstlisting}[caption={Komponenta pro navigaci}, tabsize=2, language=Kotlin]
// Soubor PspNavHost.kt

@Composable
fun PspNavHost(
	modifier: Modifier = Modifier,
	navController: NavHostController,
	onBackClick: () -> Unit
) {
	NavHost(
		modifier = modifier,
		navController = navController,
		startDestination = VotesDestination.route
	) {
		composable(route = VotesDestination.route) {
			VoteListScreen(
				onVoteClick = { id ->
					navController.navigateToVoteDetails(id)
				}
			)
		}
	
		composable(
			route = VoteDetailDestination.routeWithArgs,
			arguments = VoteDetailDestination.arguments
		) { navBackStackEntry ->
			val voteId = navBackStackEntry.arguments!!
				.getInt(VoteDetailDestination.voteIdArg)
			
			VoteScreen(
				voteId = voteId,
				onBackClick = onBackClick
			)
		}
	}
}
\end{lstlisting}

\noindent Pomocí funkce \lstinline|NavHost| vytváříme destinace pro navigaci. Každá destinace je vytvořena pomocí funkce \lstinline|composable|, která v prvním parametru akceptuje název identifikující danou destinaci \linebreak a v druhém callback funkci, která se zavolá,  když dojde k navigaci k této destinaci. Samotnou navigaci má na starosti objekt \lstinline|NavHostController|. Při navigaci na detail entity v seznamu specifikujeme navíc argumenty jak v definici destinace, tak i při navigaci.

\subsection*{Držitelé stavů}
Držitel stavu obsahuje stav UI a metody pro obsluhu událostí z prezentační vrstvy. Data získává z doménové vrstvy. je implementován pomocí view modelů. Všechny stavy v modelech jsou buď definovaný pomocí datového typu \lstinline|State| nebo \lstinline|StateFlow|. Datový typ \lstinline|StateFlow| je \linebreak flow, jejíž životní cyklus se řídí podle životního cyklu Android komponenty, v které je vytvořena. \linebreak V tomto případě je Android komponentou view model. Composable funkce reagují pouze na změny proměnných typu \lstinline|State|. Proměnné typu \lstinline|StateFlow| se v composable funkcích musí převést na typ \lstinline|State| pomocí funkce \lstinline|collectAsStateWithLifecycle|. Pokud je stavem ve view modelu stránkovaný obsah, pak je typu \lstinline|StateFlow<PagingData<T>>|, a pro použití v composable funkci se musí převést na typ \lstinline|LazyPagingItems| pomocí funkce \lstinline|collectAsLazyPagingItems|, jelikož stránkování se používá pro dlouhé seznamy a ty jsou implementovány pomocí funkce \lstinline|LazyColumn|, která vyžaduje datový typ \lstinline|LazyPagingItems|. Zde je příklad view modelu pro seznam hlasování:

\begin{lstlisting}[caption={Ukázka využití view modelu}, label={lst:view-model}, tabsize=2, language=Kotlin]
// Soubor VoteListViewModel.kt
class VoteListViewModel(
...
): ListViewModel(...) {
	
	private val _votes: MutableStateFlow<PagingData<Vote>> =
		MutableStateFlow(PagingData.empty())
	val votes: StateFlow<PagingData<Vote>> = _votes
	
	init {
		viewModelScope.launch {
			currentElectionYear.combine(searchText, ::Pair)
			.collectLatest { pair ->
				getVotes(pair.first, pair.second)
				.cachedIn(viewModelScope)
				.collect { votes ->
					_votes.value = votes
				}
				
			}
		}
	}
	
}
\end{lstlisting}

\noindent Na začátku je definován stav pomocí flowů. V rámci inicializační funkce je asynchronně pomocí coroutinů získávána data z backendu a uložena do tohoto stavu. 

\section {Implementace doménové vrstvy}
Doménová vrstva má na starosti business logiku aplikace. Jedinou business logikou aplikace je získávání dat různých typů. Zde je výčet souborů implementující doménovou vrstvu:

\begin{itemize}
	\item \textbf{GetAppStateUseCase.kt}
	\item \textbf{GetMemberDetailUseCaseen.kt}
	\item \textbf{GetMembersUseCase.kt}
	\item \textbf{GetMemberVotesUseCase.kt}
	\item \textbf{GetPartiesUseCase.kt}
	\item \textbf{GetPartyVotesUseCase.kt}
	\item \textbf{GetVoteDetailUseCase.kt}
	\item \textbf{GetVotesUseCase.kt}
\end{itemize}

\noindent Doménová vrstva slouží jako abstrakce datové vrstvy od prezentační vrstvy. Třídy nesou název jejich účelu. Tyto třídy mohou vracet přímo data z datové vrstvy (GetAppStateUseCase.kt). Mohou také prevádět seznam entit na datový typ flow, pokud chceme pracovat ve view modelu s flow (GetPartyVotesUseCase.kt). Pokud má třída vracet stránkovaný obsah, pak kód vypadá následovně:

\begin{lstlisting}[caption={Ukázka využití třídy doménové vrstvy pro získání stránkovaného seznamu hlasování}, label={lst:use-case-vote}, tabsize=2, language=Kotlin]
// Soubor GetVotesUseCase.kt
class GetVotesUseCase @Inject constructor(...) {
	
	operator fun invoke(electionYear: Int, searchText: String) = Pager(
		PagingConfig(pageSize = DEFAULT_PAGE_SIZE)
	) {
		VotesPagingSource(
			voteRepository = voteRepository,
			electionYear = electionYear,
			searchText = searchText
		)
	}
	.flow
	
}
\end{lstlisting}

\noindent Je vytvořen objekt typu \lstinline|Pager|, který na základě konfigurace v \lstinline|PagingConfig| a zdroje dat \linebreak v \lstinline|VotespagingSource| poskytne flow stránkovaných hodnot.  \lstinline|voteRepository| je repozitář z datové vrstvy, odkud budou získávána data. \lstinline|electionYear| je volební rok, aby se daly stahovat data pro určité volební období. \lstinline|searchText| ja řetězec pro případné filtrování seznamu.

\subsection {Implementace datové vrstvy}
Datová vrstva slouží pro abstrahování doménové vrstvy od konkrétních datových zdrojů. Datovým zdrojem může být např. backend nebo lokální databíze. V našem případě je použit pouze datový zdroj pro získávání data z backendu. Zde jsou soubory s repozitářemi implementujícími datovou vrstvu:

\begin{itemize}
	\item \textbf{AppStateRepositoryImpl.kt}
	\item \textbf{MemberRepositoryImpl.kt}
	\item \textbf{PartyRepositoryImpl.kt.kt}
	\item \textbf{VoteRepositoryImpl.kt.kt}
\end{itemize}

\noindent Repozitáře získávají data z konkrétních datových zdrojů a mapují seznamy na flowy, pokud se stránkovaný seznam (pak je logika pro převedení na flow ponechána na stránkovací \linebreak knihovně, která je popsána následně), a API entity na doménové entity:

\begin{lstlisting}[caption={Ukázka datové vrstvy pro data o stavu aplikace}, label={lst:use-case-repository}, tabsize=2, language=Kotlin]
class AppStateRepositoryImpl @Inject constructor(
private val pspRemoteDataSource: PspRemoteDataSource
) : AppStateRepository {
	override fun getAppState() = flow { 			
		emit(pspRemoteDataSource.getAppState().toDomain()) 
	}
}
\end{lstlisting}

\noindent Datové zdroje jsou pouze abstrakcí nad API pro získání dat. Datový zdroj je v souboru \linebreak \lstinline|PspRemoteDataSourceImpl.kt|. Zde je ukázka jeho kódu:

\newpage

\begin{lstlisting}[caption={Ukázka datového zdroje}, label={lst:data-source}, tabsize=2, language=Kotlin]
class PspRemoteDataSourceImpl @Inject constructor(
	private val pspApi: PspApi
) : PspRemoteDataSource {
	
	override suspend fun getAppState() = 
		pspApi.getAppState()
		
	...
}
\end{lstlisting}

\noindent Komunikuje se třídou \lstinline|PspApi|, která již obsahuje implementační detaily pro přístup k endpontům backendu. Specielním datovým zdrojem je stránkovací datový zdroj´, který není volán z repozitáře, ale z doménové vrstvy a repozitář je mu předán v parametru. Zde je seznam souborů se stránkovacími datovými zdroji:

\begin{itemize}
	\item \textbf{VotesPagingSource.kt}
	\item \textbf{MembersPagingSource.kt}
	\item \textbf{MemberVotesPagingSource.kt}
\end{itemize}

\noindent Implementace stránkovacích zdrojů jsou příliš dlouhé, a proto zde nebude uvedena ukázka. Poskytuje funkci \lstinline|load|, kterou lze přepsat. V této funkci máme k dispozici aktuální stav scrollovatelného seznamu, tj. aktuální číslo a velikost stránky. Na základě toho jsou získána data z backendu skrz sítovou vrstvu. V případě, že získání dat proběhlo v pořádku a nedošlo k žádné síťové chybě, je vracen objekt typu \lstinline|LoadResult.Page|, kterému jsou předána data aktuální stránky, číslo předchozí stránky a číslo následující stránky. Pokud nastane chyba, pak je vracen objekt typu \lstinline|LoadResult| reprezentující chybnou stránku.

\subsection{Implementace síťové vrstvy}
\label{sec:impl-network}

\noindent Síťová vrstva je implementována pomocí knihovny Retrofit, která umožňuje vytvářet HTTP dotazy pomocí funkcí a anotací:

\begin{lstlisting}[caption={Ukázka použití knihovny Retrofit pro získání seznamu hlasování z backendu}, label={lst:retrofit-votes}, tabsize=2, language=Kotlin]
// Soubor PspApi.kt
interface PspApi {
	
	@GET("/api/vote")
	suspend fun getVotes(
		@Query("page") page: Int,
		@Query("size") size: Int = DEFAULT_PAGE_SIZE,
		@Query("electionYear") electionYear: Int
	): List<VoteApiEntity>
	
	@GET("/api/vote/{id}")
		suspend fun getVoteDetails(
		@Path("id") id: Int,
	): VoteDetailsApiEntity
	
	// zbytek dotazu
}
\end{lstlisting}

\noindent Pomocí anotace \lstinline|@GET| specifikujeme URL adresu endpointu. Pomocí anotace \lstinline|@Query| specifikujeme query parametry. Pomocí anotace \lstinline|@Path| specifikujeme parametr v URL adrese. Data z backendu jsou ve formátu JSON. Ty se deserializují do objektů, jejichž typ je specifikován v návratovém typu funkcí.

\chapter{Implementace backendu}
V této kapitole bude popsána implementace backendu. V první podkapitole budou popsány použité nástroje a technologie. Backend je implementovaný pomocí více vrstvé \linebreak architektury: prezentační, doménova, databázová a vrstva pro synchronizaci dat. Sekce budou rozděleny tak, aby odpovídaly těmto vrstvám.

section {Použité nástroje a technologie}
V této sekci budou popsány hlavní nástroje a technologie použité pro implementaci backendu.

\subsection*{Intellij IDEA}
Backend byl vyvíjen ve vývojovém prostředí Intellij IDEA \cite{idea}. Výhody použití tohoto IDE jsou:
	
\begin{itemize}
	\item \textbf{Vestavěný inicializátor Spring Boot aplikací} -- Pomocí tohoto inicializátor lze nakonfigurovat a nastavit potřebné závislosti ve Spring Boot\footnote{Technologie Spring Boot bude popsána později.} aplikaci jednoduše naklikáním \linebreak v průvodci.
	
	\item \textbf{Klávesové zkratky} -- Toto IDE je vyvíjeno společností JetBrains, a tudíž obsahuje stejné klávesové zkratky jako Android Studio.
\end{itemize}

\subsection*{Maven}
Maven je nástroj pro automatizaci sestavování programu. Původně byl použit Gradle kvůli čitelnější syntaxi. Poté se přešlo na Maven z historických důvodů. Původně bylo v plánu backend nasadit na Cloud Azure \cite{azure}. Ten poskytoval plugin pro maven, který umožňoval backend nasadit a zprovoznit pomocí jednoho příkazu. Avšak kvůli omezené možnosti využití výpočetního výkonu byl backend nakonec nasazen na jiný FIT cloud (více v kapitole o nasazení). Na funkčnosti aplikace to však nemá žádný vliv, a proto se už nepřešlo z Mavenu na Gradle. 

\subsection*{Spring Boot}
Spring je open-source framework pro vývoj enterprise aplikací. Obshauje nástroje pro řešení různorodých problémů. Pro účely této práce byly využity nástroje pro vytvoření webových \linebreak aplikací, které lze používat i pro implementaci REST API. Nástroje Springu jsou založeny na návrhovém vzoru dependency injection.

Spring Boot je framework, který je postavený na Springu a který má za cíl redukci boilerplate kódu a nutnost počáteční konfigurace. Toto realizuje prostřednictcvím \linebreak autokonfigurace, což je vlastnost, kdy jsou jednotlivé komponenty Spring Bootu (např. rozhraní pro komunikaci s databází, webový server, ORM) automaticky nakonfigurovány pomocí defaultních hodnot. Defaultní hodnoty jsou Spring Bootem zvoleny, tak aby cílilo na nejčastější použití. Díky tomu lze nainstalovat závislost a s minimálním zásahem do konfigurace ji lze rovnou použít. Např. po instalaci knihovny JDBC a MySQL konektoru staří v konfiguračním souboru nastavit URL adresu a název databáze a databázi lze v kódu rovnou použít. Není potřeba nic navíc konfigurovat. Konfigurace lze vždy přenastavit, pokud je to bude potřeba. Další výhodou Spring Bootu je to, že objekty, které se mají přidat do jejího kontejneru s grafem závislostí pro injektování, lze specifikovat anotováním tříd. Na základě určitých anotací dokáže Spring Boot tyto třídy detekovat, vytvořit z nich instanci, a uložit instanci do kontejneru s grafem závislostí.

Alternativou ke knihovně Spring Boot je knihovna Ktor \cite{ktor}. Výhodou této knihovny je, že vývoj v ní je určený pro psaní v Kotlinu. Lze tedy využít všechny výhody tohoto jazyka. Nevýhodou je, že nepodporuje defaultně dependency injection. Musí se tedy dodatečně nainstalovat a nakonfigurovat. Další nevýhodou je chybějící autokonfigurace. Mnoho závislostí se tedy musí manuálně nakonfigurovat.

\subsubsection*{Java}
Java byla od začátku hlavním programovacím jazykem pro vývoj aplikací ve Spring Bootu. Od roku 2017 přišla integrace jazyka Kotlin do Spring Bootu \cite{kotlin-support} a v dokumentaci jsou ukázkové kódy psány jak v Javě tak i Kotlinu. Podle mého názoru má Java oproti Kotlinu větší podporu v komunitě, co se týče vývoje ve Spring Bootu. Nalezení řešení pro problém ve Spring Bootu \linebreak s Javou bylo jednodušší než ve Spring Bootu s Kotlinem. Intellij DIEA však poskytuje nástroje pro automatickou trasnformaci souboru v jazyce Java do souboru v Kotlinu. Výsledný kód bylo však potřeba vždy pročistit, jelikož u všech proměnných vždy obsahoval datové typy, které lze \linebreak v Kotlinu v některých případech pro čitelnost vynechat. Zároveň výstupní kód někdy nebyl kvůli drobnosti kompilovatelný. Z toho důvodu jsem se rozhodl pro použití Javy. Zdá se však, že podpora pro psaní aplikací Spring Boot pomocí Kotlinu je čím dál tím větší. Když bych měl možnost backend napsat znovu, pouvažoval bych znovu o použití Kotlinu, jelikož je to velmi dobrý programovací jazyk.

\section {Prezentační vrstva}
V prezentační vrstvě jsou implementovány endpointy REST API v rámci \textit{controllerů}, což je třída obsahující definice endpointů. Endpointy lze tedy seskupit do různých tříd. Controllery získávají data z doménové vrstvy. Zde je seznam souborů s controllery:

\begin{itemize}
	\item \textbf{VoteController}
	\item \textbf{PartyController}
	\item \textbf{MemberController}
	\item \textbf{AppStateController}
\end{itemize}

\noindent Zde je kus kódu pro implementaci controlleru pro endpointy související s hlasováním:

\newpage

\begin{lstlisting}[caption={Ukázka kódu pro vytvoření endpointu}, label={lst:controller-votes}, tabsize=2]
// Soubor VoteController.java
@RestController
public class VoteController {
		private final VoteService service;
		private final VoteMapper mapper;
		
		// zbytek implementace
		
	@GetMapping("/vote/{id}")
	public DetailedVote getVote(@PathVariable Integer id) {
		Vote vote = service.getVote(id);
		return mapper.toDetailedVote(vote);
	}
\end{lstlisting}

\noindent Podle anotace \lstinline|@RestController| Spring Boot pozná, že se jedná o controller a vytvoří implementaci endpointů vevnitř. Anotace \lstinline|@GetMapping| definuje URL adresu endpointu. V parametru lze specifikovat URL id parametry pomocí \lstinline{@PathVariable} a query parametry pomocí \lstinline|@RequestParam|. Data získané z doménové vrstvy (service) jsou případně transformována (mapper). U stránkovaného obsahu jsou navíc přidány HTTP hlavičky pro informace o stránkování:

\begin{lstlisting}[caption={Ukázka nastavení hlaviček pro stránkování}, label={lst:headers-paging}, tabsize=2]
// Soubor PaginationHeaderGenerator.java
public static HttpHeaders buildHeaders(int totalPages, int page) {
	HttpHeaders responseHeaders = new HttpHeaders();

	// zbytek implementace
	
	responseHeaders.set(previousPageString, String.valueOf(prevPage));
	responseHeaders.set(nextPageString, String.valueOf(nextPage));
	responseHeaders.set(lastPageString, String.valueOf(lastPage));
	
	return responseHeaders;
}
\end{lstlisting}

\noindent Spring poskytuje třídu \lstinline|HttpHeaders|, pomocí které lze sestavit HTTP hlavičky. Instance této třídy pak bude vracen spolu s daty.

\section {Doménová vrstva}
Doménová vrstva má na starosti business logiku aplikace a abstrahování prezentační vrstvy od implementačních detailů databázové vrstvy. V našem případě backend neobsahuje téměř žádnou business logoiku, pouze filtruje data nebo dozpracovává data, která nebyla z časových důvodů zpracována předem. Zde jsou soubory implementující doménovou vrstvu:

\begin{itemize}
	\item \textbf{MemberService}
	\item \textbf{PartyService}
	\item \textbf{VoteService}
\end{itemize}

\noindent Pro získání seznamů je použito stránkování, které je implementováno pomocí třídy \lstinline|Pageable|. Ta je předána repozitáři, který bude popsán v následující sekci:

\newpage

\begin{lstlisting}[caption={Ukázka doménové vrstvy pro vrácení seznamu poslanců}, label={lst:headers-paging}, tabsize=2]
// Soubor MemberService.java
public Page<Member> getMembers(PagingParams pagingParams) {
	
	Pageable pageable = PageableGenerator.buildPageable(pagingParams);
	
	if (filterName == null) {
		return memberRepository
			.findByElectionYear(electionYear, pageable);
	} else {
		// kod pro filtrovani poslancu
	}
}
\end{lstlisting}

\noindent Instance třídy \lstinline|Pageable| je vytvořena následovně:

\begin{lstlisting}[caption={Ukázka kódu pro sestavení objektu pro stránkování}, label={lst:paging-object}, tabsize=2]
// Soubor PageableGenerator.java
public static Pageable buildPageable(...) {
	Pageable pageable;
	
	...
	
	pageable = PageRequest.of(page, size, sort);
	// napr. page = 2, size = 20, sort = Sort.by("dateTime").descending())
	
	return pageable;
}

\end{lstlisting}

\noindent U metody pro získání detailu hlasování je dopočítán počet omluvených a nepřihlášených \linebreak poslanců, který nebyl spočten při zpracování, jelikož zpracování příliš zpomaloval:

\begin{lstlisting}[caption={Ukázka dopočtu statistik pro detail hlasování za běhu v doménové vrstvě}, label={lst:excused-count}, tabsize=2]
// Soubor VoteService.java
public Vote getVote(int id) throws IOException {
	...
	
	int excusedCount = ... 	
	int loggedOffCount = ...
	
	...
	
	// nastaveni hodnot excusedCount a loggedOffCount
	// vraceni vysledku
}
\end{lstlisting}

\noindent Pro získání dat z repozitářů jsou využity i streamy (proudy dat, podobně jako Kotlin Flows):

\begin{lstlisting}[caption={Ukázka použití streamu}, tabsize=2]
public List<Party> getParties(int electionYear) {
	return partyRepository
		.findByIdElectionYear(electionYear)
		.stream()
		.filter(Util::isRealParty)
		.collect(Collectors.toList());
}
\end{lstlisting}

\noindent Funkce \lstinline|findByIdElectionYear| vrátí seznam výsledků. Po té dojde k převedení na stream. Stream lze pak filtrovat. Zde byly ukázky a vysvětlení, které by měly stačit k pochopení zbylých implementací doménové vrstvy.

\section {Databázová vrstva}
Databázová vrstva je implementována pomocí repozitářů a databázových entit. Komunikace \linebreak s databází je abstrahována pomocí objektově-relačního mapování, díky kterému jsme abstrahováni od databázových tabulek a místo toho pracujeme s objekty (entitami). Pro tento účel používám knihovnu Hibernate \cite{hibernate}. Příkladem databázové entity je:

\begin{lstlisting}[caption={Entita Vote reprezentující hlasování}, label={lst:vote-entity}, tabsize=2]
// Soubor Vote.java
// dalsi anotace
@Entity(name = VOTE)
@Getter
public class Vote {
	
	@Id
	private int id;
	
	private LocalDateTime dateTime;
	
	// dalsi atributy
}
	
\end{lstlisting}

\noindent Pomocí anotace \lstinline|Entity| Hibernate pozná, že se jedná databázovou entitu a vytvoří mapování na tabulku v databázi. Anotace \lstinline|@Getter| je z knihovny Lombok a slouží pro vygenerování getterů. Anotací \lstinline|@Id| specifikujeme atribut, který má být primárním klíčem v tabulce. 

Pro implementaci repozitářů je použita knihiovna spring-data-jpa \cite{spring-jpa}, která poskytuje rozhraní \lstinline|JpaRepository|, který obsahuje základní metody pro manipulaci s danou entitou jako \linebreak např. \lstinline|findAll()| pro získání všech záznamů z tabulky nebo \lstinline|findById()| pro získání záznamu s daným id. Výhodou této knihovny je možnost vytvoření vlastních metod, kterým se říká query metody. Implementace dotazu se vygeneruje na základě pojmenování query metody. Toto pojmenování se řídí podle určitých pravidel, které jsou popsány v dokumentaci \cite{spring-jpa}. Např. následující metoda vrací seznam hlasování v daném volebním období:

\begin{lstlisting}[caption={Repozitář pro hlasování}, label={lst:be-repository-vote}, tabsize=2]
// Soubor VoteRepository.java
@Repository
public interface VoteRepository extends JpaRepository<Vote, Integer> {
	
	...
	
	List<Vote> findByElectionYear(int electionYear);
	
}
\end{lstlisting}

\noindent Zde je seznam souborů s repozitáři:

\begin{itemize}
	\item \textbf{VoteRepository.java}
	\item \textbf{MemberRepository.java}
	\item \textbf{MemberVoteRepository.java}
	\item \textbf{AgencyRepository.java}
	\item \textbf{ExcuseRepository.java}
	\item \textbf{MembershipRepository.java}
	\item \textbf{PartyRepository.java}
\end{itemize}

\section{Zpracování dat}
Backend každý den o půl noci aktualizuje databázi podle zdrojových dat na webu PSP. Aktualizace probíhá v následujících krocích:

\begin{itemize}
	\item \textbf{Stažení zdrojových souborů} -- Zdrojové soubory jsou ve formátu zip a jsou stažené z webu PSP.
	\item \textbf{Extrakce datových souborů} -- Ze zdrojových souborů jsou vyextrahovány datové soubory.
	\item \textbf{Pročištění dat} -- Z datových souborů jsou odstraněny duplicitní data.
	\item \textbf{Parsování dat} -- Datové soubory jsou zparsovány a načteny do Java objektů.
	\item \textbf{Transformace dat} --  Objekty jsou ztransformovány do databázového modelu.
	\item \textbf{Uložení dat do databáze} -- Ztransfomovaná data jsou perzistentně uložena do databáze.
\end{itemize}

\subsection{Stahování zdrojových souborů}
Stahování zdrojových souborů má na starosti třída následující třída:

\begin{lstlisting}[caption={Třída pro stahování zdrojových souborů}, label={lst:psp-downloader}, tabsize=2]
// Soubor PspFilesDownloader.java
public class PspFilesDownloader {
	public static void downloadFiles() throws IOException {
		downloadHlasovani();
		downloadPoslanci();
	}

	// dalsi metody
}
\end{lstlisting}

\noindent Pro stahování souborů je použita funkce \lstinline|copyURLToFile| z knihovny \lstinline|commons-io| \cite{commons-io}. Tato funkce stáhne soubor na dané URL do dané složky a s daným názvem:

\newpage

\begin{lstlisting}[caption={Ukázka stahování dat pomocí knihovny \lstinline|commons-io|}, label={lst:common-io-downloader}, tabsize=2]
// Soubor FileDownloader.java
public class FileDownloader {
	
	public static void download(
		String downloadUrlString, 
		String downloadDestination) {
		
		File file = new File(downloadDestination);
		URL downloadUrl = new URL(downloadUrlString);
		
		FileUtils.copyURLToFile(downloadUrl, file);
	
		...
	}
}
\end{lstlisting}

\subsection{Extrakce datových souborů}
Pro extrakci souborů ze zip byla použita funkce funkce \lstinline|extractFile| třídy \lstinline|ZipFile| z knihovny \lstinline|zip4j| \cite{zip4j}. Ta na základě názvu souboru, který se má vyextrahovat, vyextrahuje daný soubor do dané složky a soubor bude mít daný název:

\begin{lstlisting}[caption={Ukázka extrakce souborů ze zipu}, label={lst:zip4j}, tabsize=2]
// Soubor ZipExtractor.java
public class ZipExtractor {

	public static void extract(
		String pathToZip, 
		String fileToExtract, 
		String destinationDir
	) {
		ZipFile zipFile = new ZipFile(pathToZip)
		zipFile.extractFile(fileToExtract, destinationDir, fileToExtract);
		
	}
		
}
\end{lstlisting}

\subsection{Pročištění dat}
Duplicitní záznamy jsou odstraněny pomocí skriptu napsaného v jazyce Bash:

\begin{lstlisting}[caption={Skript pro odstranění duplicitních řádků}, tabsize=2]
// Soubor removeDuplicates.sh.java
for FILE in "$1"/*; do
	sort "$FILE" | uniq > 'tmp.unl'
	mv 'tmp.unl' "$FILE"
	rm 'tmp.unl'
done
\end{lstlisting}

\noindent Skript funguje následovně:

\begin{itemize}
	\item Skript předpokládá ve svém prvním argumentu cestu ke adresáři, kde se nachází datové soubory.
	
	\item Na začátku se iteruje přes všechny soubory v daném adresáři.
	
	\item Každý soubor se pomocí příkazu \lstinline|sort| seřadí vzestupně podle abecedy.
	
	\item Ze seřazeného souboru se odstraní duplicitní řádky jdoucí za sebou pomocí příkazu \lstinline|uniq|. Vy tuto chvíli jsou ze souboru odstraněny všechny duplicity.
	
	\item Zbytek kódu již je pouze přesouvání obsahů souborů tak, aby datové soubory s odstraněnými duplicity měly jejich originální název.
\end{itemize}

\noindent Skript je volán ze souboru \lstinline|PspFilesCleaner|. Důvodem pro odstranění duplicit pomocí jazyka Bash a ne přímo pomocí Javy je rychlost Bashe pro tento účel a jednoduchá manipulace se soubory.

\subsection{Parsování dat}
Pro parsování zdrojových dat používám knihovnu \lstinline|opencsv|. Ta umožňuje parsovat CSV přidáním anotací k atributům třídy. Tyto anotace specifikují pozici sloupce v CSV souboru, na který se atribut namapuje:

\begin{lstlisting}[caption={Parsování datového souboru omluvy.unl}, tabsize=2]
// Soubor Omluva.java
public class Omluva {
	@CsvBindByPosition(position = 0)
	private int idOrgan;
	
	@CsvBindByPosition(position = 1)
	private int idPoslanec;

	// dalsi atributy	
}
\end{lstlisting}

\noindent Všechny parsery se nachází ve složce \lstinline|parsers|. Pro parsování je použita knihovna \cite{opencsv}. Ta poskytuje třídu \lstinline|CsvToBeanBuilder|, pomocí které lze parsovat CSV soubory a namapovat je na objekty vytvořené s anotacemi, jak popsáno výše. Dále poskytuje metody pro nastavení oddělovače, detekci nullové hodnoty a možnost ignorování uvozovek:

\begin{lstlisting}[caption={Parsování datového souboru omluvy.unl}, tabsize=2]
// Soubor OmluvyParser.java
public class OmluvyParser extends UnlParser {
	public List<Omluva> read() {
		String filePath = PspPath.Unl.OMLUVY;
		BufferedReader reader = getReader(filePath);
		
		return new CsvToBeanBuilder<Omluva>(reader)
		.withType(Omluva.class)
		.withSeparator(UNL_SEPARATOR)
		.withFieldAsNull(UNL_NULL_SEPARATOR)
		.withIgnoreQuotations(true)
		.build()
		.parse();
		
	}
}
	
\end{lstlisting}

\subsection{Transformace a uložení dat}
Po zpasrování datových souborů a namapování záznamů na objekty lze tyto objekty začít ztransformovat do databázového modelu. Všechny soubory pro transformaci se nachází ve složce \lstinline|loaders|. V rámci transformátoru se vždy zavolá příslušný parser, který vrátí data, ty se ztranformují \linebreak a následně uloží do databáze:

\begin{lstlisting}[caption={Transformace objektu Omluva na databázový objekt Excuse}, tabsize=2]
// Soubor ExcuseLoader.java
	
public class ExcuseLoader extends BaseLoader {

    private final OmluvyParser omluvyReader;
    private final ExcuseRepository excuseRepository;

    public void load() {
			excuseRepository.deleteAllInBatch();
			List<Omluva> omluvaList = omluvyReader.read();
			
			List<Excuse> excuses = omluvaList.parallelStream()
						.map(omluva -> {
							// transformace
						})
					.collect(Collectors.toList());
				
			Lists
				.partition(excuses, BATCH_SIZE)
				.forEach(excuseRepository::saveAll);

	}

}
\end{lstlisting}

\noindent 
Před samotným parsováním jsou smazány všechny záznamy v příslušné tabulce. Poté probíhá parsování datových souborů a seznamu namapovaných objekt. Z tohoto seznamu je vytvořen paralelní stream, což stream, který potenciálně zpracuje objekt v seznamu paralelně. Každý objekt je ztransformován a namapován na databázový objekt. Ztransformovaná data jsou perzistetně uložena do databáze. Ukládání je optimalizováno tak, že se neukládá po jednom ale po skupinách. Každá skupina obsahuje 1000 objektů. Ukládáme tedy po 1000 objektech.

